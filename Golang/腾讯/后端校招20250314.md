# 后端校招20250121

更新 9月22日 意向书

更新 9月7日云证 状态更新已完成

老天保佑别有什么幺蛾子 不然我哭死?

太不容易了 今年优图没hc 腾讯实习了个寂寞 但是没想到提前批还挺顺利（毕竟面试部门缺人 加班到妻

离子散

磕磕绊绊地复习 其他大厂都秒挂 只求去tx加班了

发个1~3面+hr面的面经，顺便求hr面顺利早日oc！

本人java选手，实习是python，腾讯要求go。

### 一面 8月19日

1、问实习项目（没细问）

2、问go的掌握程度

**3、网络**

## （1）TCP第四次挥手客户端的状态

在TCP四次挥手的第四次挥手中，客户端会接收到服务器发来的最后一个FIN报文（通常是第三次挥手），表示服务器也同意关闭连接，并且服务器已经完成了数据发送。  客户端在接收到这个FIN报文后，会**向服务器发送一个ACK确认报文**，这个ACK报文就是第四次挥手的关键。  **发送完这个ACK报文之后，客户端就会进入 TIME_WAIT 状态。**

**客户端进入 TIME_WAIT 状态，并且会持续 2MSL (Maximum Segment Lifetime)  时长。  MSL 指的是报文在网络中最大的生存时间。  2MSL 就是两倍的MSL时长。**  这个状态的存在至关重要，主要有以下两个目的：

- **确保最后一个ACK报文能够到达服务器：**  虽然TCP是可靠传输协议，但是网络环境是复杂的，最后一个ACK报文仍然有可能丢失。  如果客户端发送完ACK就直接进入 `CLOSED` 状态，万一这个ACK丢失，服务器没有收到ACK，服务器会认为客户端没有收到自己的FIN报文，从而会重新发送FIN报文。  **处于 TIME_WAIT 状态的客户端，如果收到服务器重传的FIN报文，会再次发送ACK报文进行确认，并重启 TIME_WAIT 计时器。** 这样就最大程度上保证了连接的可靠关闭。
- **防止“旧连接”的数据包在新连接中出现：**  在网络中，报文可能会因为路由等原因延迟到达。  如果客户端在发送完ACK后立即进入 `CLOSED` 状态，并且立即使用相同的端口号和IP地址对建立新的连接，那么之前连接中延迟到达的数据包就有可能在新连接建立后才到达。  **TIME_WAIT 状态的存在，可以保证在 2MSL 时间内，所有旧连接的数据包都会在网络中消失，避免了旧连接的数据包干扰新的连接。**  等待 `2MSL` 时间后，客户端才会最终进入 `CLOSED` 状态，彻底释放资源。



## （2）大量time_wait会有什么问题，time_wait的时候能不能有别的客户端来请求服务器的服务

**资源占用增加 (端口资源是关键)**



## （3）TCP全连接和半连接队列（不会）

清晰地定义全连接队列，并强调其作用是存放已经完成三次握手，处于 ESTABLISHED 状态，但尚未被 `accept()` 的连接。  明确指出它在三次握手中的位置和作用阶段。  强调 "等待被 `accept()`" 的状态。

- **半连接队列：** 用于存放 **尚未完成三次握手** 的连接请求 (处于 SYN_RECEIVED 状态)。 目的是 **缓存** 这些半连接，等待第三次握手完成。 **防止 SYN 报文丢失重传期间，服务器资源被耗尽。**
- **全连接队列：** 用于存放 **已经完成三次握手，但尚未被应用程序 accept()** 的连接 (处于 ESTABLISHED 状态)。 目的是 **缓冲** 已经建立好的连接，等待应用程序处理。 **防止应用程序处理速度慢，导致连接请求丢失。**



## （4）滑动窗口已经发送序号为1、2、3的包，此时接收端发送ACK=4，问滑动窗口是否会移动？



## （5）http状态码

**HTTP 状态码主要分为五大类，通过状态码的第一位数字来区分：**

- **1xx (Informational - 信息性状态码):** 表示服务器 **已接收到请求的初始部分**，正在继续处理，等待客户端的后续请求或指示。这类状态码在实际开发中相对较少见，但了解它们的存在也很重要。
- **2xx (Success - 成功状态码):** 表示服务器 **已成功接收、理解并处理了客户端的请求**。 这是我们最希望看到的响应状态码，表示一切正常。
- **3xx (Redirection - 重定向状态码):** 表示客户端 **请求的资源发生了变动**，服务器 **指示客户端需要采取进一步的操作** (通常是重新请求另一个 URI) 才能完成请求。 这类状态码主要用于处理资源移动、临时跳转等场景。
- **4xx (Client Error - 客户端错误状态码):** 表示客户端的 **请求本身存在错误**，导致服务器 **无法或拒绝处理**。 这类状态码通常意味着客户端需要检查并修改请求内容。
- **5xx (Server Error - 服务器错误状态码):** 表示服务器在 **处理客户端的有效请求时发生了错误**，导致服务器 **无法完成请求**。 这类状态码通常意味着服务器端出现了问题，需要检查服务器配置或代码。

**2xx (Success - 成功状态码) -  最常用，务必掌握:**

- **200 OK:** **请求成功**。 这是最常见的成功状态码，表示服务器已成功处理了请求，并且响应体中包含了请求的数据。 例如，GET 请求成功获取资源，POST 请求成功创建资源等。
- **201 Created:** **请求成功，并且服务器成功创建了新的资源**。 通常用于 POST 请求，表示资源创建成功。 响应头中可能会包含 `Location` 字段，指向新创建资源的 URI。
- **204 No Content:** **请求成功，但服务器没有返回任何响应体**。 通常用于 DELETE 请求，表示资源删除成功，或者 PUT/PATCH 请求成功更新资源，但客户端不需要新的资源状态。 响应头中可能包含元信息。

**3xx (Redirection - 重定向状态码) -  理解重定向机制，掌握常用代码:**

- **301 Moved Permanently:** **永久重定向**。 表示请求的资源 **永久性地** 移动到了新的 URI。 客户端在收到 301 响应后，应该更新书签或链接，以后都应该使用新的 URI 来访问资源。 搜索引擎也会根据 301 响应更新索引。 响应头中必须包含 `Location` 字段，指向新的 URI。
- **302 Found (以前是 302 Moved Temporarily):** **临时重定向**。 表示请求的资源 **临时性地** 移动到了新的 URI。 客户端在收到 302 响应后，应该 **临时** 使用新的 URI 来访问资源，但 **以后仍然应该使用原始的 URI**。 搜索引擎通常不会根据 302 响应更新索引。 响应头中必须包含 `Location` 字段，指向新的 URI。

**4xx (Client Error - 客户端错误状态码) -  关注常见错误类型，排查客户端问题:**

- **400 Bad Request:** **客户端请求错误**。 这是一个通用的客户端错误状态码，表示服务器 **无法理解或处理客户端的请求**。 可能是由于请求语法错误、参数错误、请求头错误等原因。 具体的错误原因通常会在响应体中描述。
- **401 Unauthorized:** **未授权**。 表示客户端 **需要身份验证** 才能访问资源。 服务器返回 401 状态码时，通常会包含 `WWW-Authenticate` 响应头，指示客户端需要使用的身份验证方案。 与 403 Forbidden 的区别在于，401 表示身份验证未通过，而 403 表示身份验证已通过，但仍然没有权限访问资源。
- **403 Forbidden:** **禁止访问**。 表示服务器 **理解客户端的请求，但拒绝执行**。 可能是由于客户端 **没有权限** 访问该资源，即使身份验证通过了也没有用。 或者服务器出于安全原因，禁止访问该资源。 与 401 Unauthorized 的区别在于，403 表示已经验证身份了，但是没有权限。
- **404 Not Found:** **未找到**。 表示服务器 **找不到请求的资源**。 这是非常常见的错误状态码，通常意味着客户端请求的 URI 路径不正确，或者资源已经被删除。 **注意：404 并不一定意味着服务器端真的没有这个资源，也可能是服务器故意返回 404 以隐藏资源的存在，例如出于安全考虑。**

**5xx (Server Error - 服务器错误状态码) -  关注服务器端错误，排查服务器问题:**

- **500 Internal Server Error:** **服务器内部错误**。 这是一个通用的服务器错误状态码，表示服务器在处理请求时 **遇到了未预期的错误**，导致无法完成请求。 具体的错误原因通常会在服务器的日志中记录，客户端通常无法获取详细的错误信息。 **500 错误通常表示服务器端代码或配置存在 bug。**
- **502 Bad Gateway:** **错误的网关**。 通常发生在 **反向代理服务器** 或 **网关服务器** 的场景中。 表示网关服务器在尝试 **向上游服务器** (例如，应用服务器) **请求资源时，收到了无效的响应** (例如，上游服务器宕机、超时、返回了错误的 HTTP 响应)。
- **503 Service Unavailable:** **服务不可用**。 表示服务器 **暂时无法处理请求**。 可能是由于服务器 **过载、维护、宕机** 等原因。 服务器返回 503 状态码时，通常会包含 `Retry-After` 响应头，指示客户端应该在多久之后重试请求。 与 500 Internal Server Error 的区别在于，503 通常表示服务器是 **暂时性** 的不可用，而 500 通常表示服务器代码或配置存在 **永久性** 的错误。
- **504 Gateway Timeout:** **网关超时**。 类似于 502 Bad Gateway，也常发生在 **反向代理服务器** 或 **网关服务器** 的场景中。 表示网关服务器在 **等待上游服务器响应时超时**，超过了预设的时间限制。 可能是由于上游服务器处理请求时间过长、网络延迟过高、上游服务器宕机等原因。

401 vs 403, 500 vs 503



## （6）https的握手过程，双方通信是非对称还是对称

**总结一下，在 HTTPS 握手过程中，会同时使用非对称加密和对称加密：**

- 非对称加密 (Public Key Cryptography)主要用于握手阶段 的以下几个关键环节：
  - **服务器证书的数字签名验证:** 客户端使用 CA 的公钥验证服务器证书的签名，确保证书的真实性和完整性。
  - **密钥交换 (Key Exchange):** 例如 RSA 密钥交换中，客户端使用服务器公钥加密预主密钥； DH/ECDHE 算法本身也基于非对称加密的数学原理。 **非对称加密的主要目的是安全地协商出一个共享的秘密 (预主密钥)。**
- **对称加密 (Symmetric Key Cryptography):** 主要用于 **握手完成后的数据通信阶段**。 客户端和服务器使用 **握手阶段协商生成的对称会话密钥** 对所有应用数据进行加密和解密。 **对称加密的主要目的是高效地加密和解密大量的数据。**

**因此，HTTPS 双方在完成握手后的通信是使用 对称加密  进行加密的。**





## （7）你知道什么加密算法（不知道）

**1. 对称加密算法 (Symmetric Encryption Algorithms):**

- **DES (Data Encryption Standard):** **数据加密标准**。 一种较早期的对称加密算法，密钥长度较短 (56位)，现在 **已经被认为是不安全的**，容易被暴力破解。 **不推荐在新的系统中使用 DES。**
- **3DES (Triple DES):** **三重 DES**。 为了增强 DES 的安全性，使用了三重 DES 加密，即对数据进行三次 DES 加密。 密钥长度增加到 112位或 168位，安全性有所提高，但 **加密效率较低**，现在也 **逐渐被更安全的算法取代**。
- **AES (Advanced Encryption Standard):** **高级加密标准**。 目前 **最流行、最广泛使用的对称加密算法**。 AES 算法安全性高，加密速度快，支持多种密钥长度 (128位、192位、256位)。 **AES 是对称加密的首选算法，广泛应用于各种场景，例如 HTTPS 加密通信、数据存储加密、文件加密等。** 常见的 AES 工作模式有 ECB, CBC, CTR, GCM 等，其中 GCM 模式还提供了认证加密的功能。
- **ChaCha20:** 一种 **流密码算法**。 由 Google 设计，**性能很高，尤其在软件实现上比 AES 更快**，并且 **抗侧信道攻击能力强**。 ChaCha20 通常与 Poly1305 消息认证码 (MAC) 结合使用，构成 ChaCha20-Poly1305 算法套件，被广泛应用于 HTTPS 加密 (例如 TLS 1.3 中是可选的加密套件)、移动端加密等场景。 **ChaCha20 是 AES 的有力竞争者，尤其在对性能要求较高的场景下。**

**2. 非对称加密算法 (Asymmetric Encryption Algorithms):**

- **RSA (Rivest-Shamir-Adleman):** **RSA 算法是目前最经典、最广泛使用的非对称加密算法**。 基于大数分解的数学难题，安全性较高。 **RSA 算法既可以用于加密，也可以用于数字签名。** 在 HTTPS 中，RSA 常用于密钥交换和数字证书的签名。 但 **RSA 算法加密速度相对较慢**，不适合加密大量数据。 密钥长度通常为 1024位、2048位或 4096位，密钥长度越长，安全性越高，但性能也越低。
- **DSA (Digital Signature Algorithm):** **数字签名算法**。 **DSA 算法主要用于数字签名，而不是用于加密**。 DSA 算法的签名速度较快，但验签速度相对较慢。 安全性依赖于离散对数难题。

**3. 哈希算法 (Hash Algorithms):**

- **MD5 (Message Digest Algorithm 5):** **消息摘要算法 5**。 一种较早期的哈希算法，曾被广泛使用。 但 **MD5 算法已经被证明存在安全漏洞，容易发生哈希碰撞**，即不同的输入可能产生相同的哈希值，因此 **不推荐在安全性要求高的场景中使用 MD5，例如密码存储。** MD5 现在主要用于文件完整性校验、数据校验等非安全敏感的场景。
- **SHA-1 (Secure Hash Algorithm 1):** **安全哈希算法 1**。 SHA-1 算法也和 MD5 类似，是一种较早期的哈希算法。 **SHA-1 算法也已经被证明存在理论上的安全漏洞，虽然实际攻击难度较高，但也被逐渐淘汰**。 **不推荐在新的安全系统中使用 SHA-1。**
- **SHA-2 (Secure Hash Algorithm 2):** **安全哈希算法 2**。 SHA-2 实际上是一组哈希算法的统称，包括 SHA-256, SHA-384, SHA-512 等，它们的主要区别在于输出的哈希值长度不同 (分别是 256位、384位、512位)。 **SHA-2 算法目前被认为是安全的哈希算法，是现在最广泛使用的哈希算法之一**，在数字签名、数据完整性校验、密码存储等领域都有广泛应用。 **SHA-256 是 SHA-2 系列中最常用的一种。**
- **SHA-3 (Secure Hash Algorithm 3):** **安全哈希算法 3**。 SHA-3 算法是 Keccak 算法的标准化版本，是 **SHA-2 算法的下一代标准**。 **SHA-3 算法安全性更高，性能也很好，但目前普及程度不如 SHA-2**。 随着 SHA-2 算法未来可能面临的安全风险，SHA-3 有望成为未来的主流哈希算法。



## （8）（nginx）负载均衡的几种方式

1. **内置的负载均衡策略 (Built-in Load Balancing Methods):** Nginx 核心模块 `ngx_http_upstream_module` 提供的基本负载均衡算法，无需额外模块，配置简单。
2. **基于第三方模块的负载均衡策略 (Third-party Module Load Balancing Methods):** 通过安装和配置第三方模块，可以扩展 Nginx 的负载均衡能力，提供更灵活和高级的策略。
3. **结合外部服务实现的动态负载均衡 (Dynamic Load Balancing with External Services):** 与服务发现系统 (如 Consul, ZooKeeper, Nacos) 集成，实现后端服务器列表的动态更新和管理。

**1. 内置的负载均衡策略 (Built-in Load Balancing Methods):**

这些策略都是在 `upstream`  配置块中通过指令来指定的。  如果没有显式指定负载均衡策略，默认使用 **轮询 (Round Robin)** 策略。

- **轮询 (Round Robin):**  **默认策略**。  请求会 **依次** 分发到 `upstream`  配置块中列出的后端服务器。  每台服务器按照顺序接收请求。

  - **工作原理:**  Nginx 维护一个后端服务器列表，每次接收到新的请求时，就从列表中选择下一个服务器来处理请求。  循环往复。

  - **Nginx 配置示例:**

    ```nginx
    upstream backend {
        server backend1.example.com;
        server backend2.example.com;
        server backend3.example.com;
    }
    
    server {
        location / {
            proxy_pass http://backend;
        }
    }
    
    ```

  - **优点:**  配置简单，实现容易，负载均衡相对均匀。

  - **缺点:**  没有考虑后端服务器的实际负载情况，如果后端服务器性能差异较大，或者某些服务器负载过高，可能会导致性能瓶颈。  **无法处理会话保持 (Session Persistence) 的问题。**  如果后端某台服务器宕机，需要等待健康检查 (健康检查默认是关闭的，需要配置) 才能将其剔除。

  - **适用场景:**  后端服务器性能相近，且不需要会话保持的场景。  例如，简单的静态资源服务、无状态的 API 服务等。

- **最少连接 (Least Conn):**  将请求 **优先分发到当前连接数最少的后端服务器**。

  - **工作原理:**  Nginx 会跟踪每个后端服务器的当前活跃连接数，每次接收到新的请求时，就选择当前连接数最少的服务器来处理请求。

  - **Nginx 配置示例:**

    ```nginx
    upstream backend {
        least_conn;
        server backend1.example.com;
        server backend2.example.com;
        server backend3.example.com;
    }
    
    server {
        location / {
            proxy_pass http://backend;
        }
    }
    
    ```

  - **优点:**  能够根据后端服务器的实际负载情况动态分配请求，**更好地利用服务器资源，提高整体性能**。  适用于后端服务器性能差异较大，或者请求处理时间差异较大的场景。

  - **缺点:**  实现相对轮询策略复杂一些，性能开销略高。  **同样无法处理会话保持的问题。**  在连接数非常接近的情况下，可能仍然无法做到绝对的负载均衡。

  - **适用场景:**  后端服务器性能差异较大，或者请求处理时间差异较大的场景。  例如，CPU 密集型应用、IO 密集型应用等。

- **IP Hash:**  根据客户端的 **IP 地址的哈希值**  来分配请求，**将来自同一个 IP 地址的请求始终转发到同一台后端服务器**。

  - **工作原理:**  Nginx 对客户端 IP 地址进行哈希运算，然后根据哈希值和后端服务器数量取模，得到要选择的后端服务器。  **保证来自同一 IP 的客户端的请求始终被路由到同一台服务器。**

  - **Nginx 配置示例:**

    ```nginx
    upstream backend {
        ip_hash;
        server backend1.example.com;
        server backend2.example.com;
        server backend3.example.com;
    }
    
    server {
        location / {
            proxy_pass http://backend;
        }
    }
    ```

  - **优点:**  **可以实现简单的会话保持 (Session Persistence)**，保证同一个客户端的会话始终落在同一台服务器上，适用于需要会话保持的应用场景 (例如，基于 Cookie 的 Session)。

  - **缺点:**  **负载均衡不均匀**，如果某些客户端 IP 地址段的访问量特别大，会导致后端服务器负载不均衡。  **缺乏弹性**，当后端服务器数量发生变化时 (例如扩容或缩容)，会话可能会失效，因为 IP 哈希的映射关系会发生改变。  **对于客户端 IP 地址经常变化的场景 (例如移动端用户)，会话保持效果不佳。**

  - **适用场景:**  需要简单的会话保持，且后端服务器数量相对固定，客户端 IP 地址分布相对均匀的场景。  例如，早期的 Web 应用，或者内部系统。  **现在更推荐使用更专业的 Session 保持方案，例如 Redis, Memcached 等。**

- **2. 基于第三方模块的负载均衡策略 (Third-party Module Load Balancing Methods):**

  Nginx 社区提供了许多第三方模块，可以扩展 Nginx 的负载均衡能力，提供更高级的策略。  这里介绍一些常用的模块和策略：

  - **加权轮询 (Weighted Round Robin):**  在轮询策略的基础上，**为每台后端服务器设置权重**，权重高的服务器接收到请求的概率更高。

    - **工作原理:**  Nginx 在轮询时，会根据服务器的权重比例来分配请求。  例如，如果服务器 A 的权重为 2，服务器 B 的权重为 1，那么服务器 A 接收到的请求数量大约是服务器 B 的两倍。

    - **Nginx 配置示例:**

      ```nginx
      upstream backend {
          server backend1.example.com weight=2;
          server backend2.example.com weight=1;
          server backend3.example.com weight=1;
      }
      
      server {
          location / {
              proxy_pass http://backend;
          }
      }
      
      ```

    - **优点:**  **可以根据后端服务器的性能差异或负载能力，更精细地分配请求**，充分利用高性能服务器的资源。  例如，对于新上线的服务器，可以设置较低的权重，逐步增加权重。

    - **缺点:**  配置相对轮询策略略微复杂。  **仍然无法处理会话保持的问题。**  权重值的设置需要根据实际情况进行调整和优化。

    - **适用场景:**  后端服务器性能存在差异，需要根据服务器性能进行负载分配的场景。  例如，新旧服务器混合部署、不同配置的服务器集群等。

  - **Fair 策略 (使用 ngx_http_upstream_fair_module 模块):**  **根据后端服务器的响应时间来动态分配请求**，响应时间短的服务器优先接收请求。

    - **工作原理:**  `ngx_http_upstream_fair_module`  模块会 **动态地监控后端服务器的响应时间**，并根据响应时间的长短来决定如何分配新的请求。  响应时间越短的服务器，说明负载越轻，处理能力越强，因此会被优先选择。

    - **Nginx 配置示例:**

      ```nginx
      upstream backend {
          fair;  # 使用 fair 策略
          server backend1.example.com;
          server backend2.example.com;
          server backend3.example.com;
      }
      
      server {
          location / {
              proxy_pass http://backend;
          }
      }
      
      ```

    - **优点:**  **能够更智能地根据后端服务器的实际响应情况来分配请求，更好地提高整体性能和用户体验**。  尤其适用于后端服务器响应时间波动较大的场景。

    - **缺点:**  需要安装第三方模块 `ngx_http_upstream_fair_module`。  性能开销比轮询和最少连接策略略高，因为需要动态监控响应时间。  **仍然无法处理会话保持的问题。**

    - **适用场景:**  后端服务器响应时间波动较大，需要根据响应时间动态调整负载分配的场景。  例如，动态内容服务、API 服务等。

  - **URL Hash 策略 & Generic Hash 策略 (使用 ngx_http_upstream_hash_module 模块):**  **根据请求的 URL 或其他自定义的 key 进行哈希**，将具有相同哈希值的请求始终转发到同一台后端服务器。

    - **工作原理:**  `ngx_http_upstream_hash_module`  模块可以根据指定的 key (例如 `$request_uri` 表示请求的 URL,  `$cookie_session_id` 表示 Cookie 中的 session_id 等) 进行哈希运算，然后根据哈希值和后端服务器数量取模，得到要选择的后端服务器。

    - **Nginx 配置示例 (URL Hash):**

      ```nginx
      upstream backend {
          hash $request_uri;  # 使用 URL Hash 策略
          server backend1.example.com;
          server backend2.example.com;
          server backend3.example.com;
      }
      
      server {
          location / {
              proxy_pass http://backend;
          }
      }
      
      ```

    - **Nginx 配置示例 (Generic Hash, 基于 Cookie):**

      ```nginx
      upstream backend {
          hash $cookie_session_id consistent; # 使用 Generic Hash 策略，基于 Cookie，并启用 consistent hashing
          server backend1.example.com;
          server backend2.example.com;
          server backend3.example.com;
      }
      
      server {
          location / {
              proxy_pass http://backend;
          }
      }
      ```

    - **优点:**  **可以实现更灵活的会话保持 (Session Persistence)**，可以根据 URL、Cookie、Header 等自定义 key 进行会话绑定。  **Generic Hash 策略还可以结合 consistent 参数启用一致性哈希 (Consistent Hashing)**，提高后端服务器扩容或缩容时的会话保持稳定性。

    - **缺点:**  需要安装第三方模块 `ngx_http_upstream_hash_module`。  负载均衡的均匀性取决于哈希 key 的分布情况，如果哈希 key 分布不均匀，可能导致负载不均衡。  **一致性哈希虽然提高了稳定性，但实现更复杂，性能开销也略高。**

    - **适用场景:**  需要更灵活的会话保持，例如基于 URL 或 Cookie 的会话保持。  需要支持一致性哈希，提高扩容或缩容时的会话保持稳定性的场景。  例如，复杂的 Web 应用、电商平台等。

  - **Least Time 策略 (使用 ngx_http_upstream_least_time_module 模块):**  **根据后端服务器的响应时间和连接数综合考虑，选择响应时间最短且连接数最少的服务器**。

    - **工作原理:**  `ngx_http_upstream_least_time_module`  模块会 **同时监控后端服务器的响应时间和当前连接数**，并综合考虑这两个指标来选择最佳的后端服务器。  可以配置只考虑响应时间 (`least_time connect`)，只考虑首字节响应时间 (`least_time processing`)，或者同时考虑响应时间和连接数 (`least_time connect processing`)。

    - **Nginx 配置示例:**

      ```nginx
      upstream backend {
          least_time connect processing;  # 使用 Least Time 策略，同时考虑连接时间和处理时间
          server backend1.example.com;
          server backend2.example.com;
          server backend3.example.com;
      }
      
      server {
          location / {
              proxy_pass http://backend;
          }
      }
      ```

    - **优点:**  **综合考虑了响应时间和连接数，能够更全面地反映后端服务器的负载情况和性能**，选择最佳的服务器处理请求，进一步提高性能和用户体验。

    - **缺点:**  需要安装第三方模块 `ngx_http_upstream_least_time_module`。  性能开销较高，因为需要同时监控响应时间和连接数。  **仍然无法处理会话保持的问题。**

    - **适用场景:**  对性能和用户体验要求极高的场景，需要尽可能选择最佳后端服务器处理请求。  例如，高并发 API 服务、实时性要求高的应用等。



**4、操作系统**

## （1）孤儿进程、僵尸进程



## （2）进程的通信方式



## （3）进程的调度方式（最短作业优先的缺点）

1. **非抢占式调度 (Non-preemptive Scheduling):** 一旦进程被分配到 CPU，就会一直运行直到进程完成或者主动放弃 CPU (例如，等待 I/O)。 在非抢占式调度中，调度程序不会主动中断正在运行的进程。

- **先来先服务 (First-Come, First-Served, FCFS):**  也称为 **先进先出 (FIFO)** 调度算法。  **按照进程到达就绪队列的顺序**  来分配 CPU。  先到达的进程先被调度执行，后到达的进程等待。
  - **工作原理:** 维护一个就绪队列，新到达的进程添加到队尾。 调度程序每次从队头选择进程执行，直到进程完成或阻塞。
  - **优点:** **简单易于实现**，公平性好 (按照到达顺序)，实现开销小。
  - **缺点:** **短进程等待时间过长**，不利于短进程和交互式进程。 可能导致 convoy effect (护航效应)**，即一个长进程占用 CPU 导致后续所有短进程都必须等待，降低 CPU 和设备利用率。 **对长进程有利，对短进程不利。
  - **适用场景:** **适用于批处理系统**，对交互性要求不高，长作业为主的系统。 例如，早期的批处理操作系统。
- **短作业优先 (Shortest-Job-First, SJF):**  也称为 **短进程优先 (Shortest-Process-Next, SPN)** 调度算法。  **选择就绪队列中估计运行时间最短的进程**  来分配 CPU。
  - **工作原理:** 需要预先知道每个进程的运行时间 (或者根据历史数据进行估计)。 调度程序每次从就绪队列中选择估计运行时间最短的进程执行。
  - **优点:** **平均等待时间、平均周转时间最短**，能够有效提高系统的吞吐量。 **对短进程非常有利。**
  - **缺点:** **难以准确预测进程的运行时间**，实际应用中很难实现纯粹的 SJF 算法。 **可能导致长进程饥饿**，如果不断有短进程到来，长进程可能永远得不到执行机会。 **不公平，对长进程不利。** 需要预知进程运行时间，实现开销较大。
  - **适用场景:** **理论上的最优算法**，常用于性能评估的基准。 可以作为其他调度算法的参考。 在某些特定场景下，如果可以比较准确地估计进程运行时间，可以考虑使用 SJF 的变体。
- **优先级调度 (Priority Scheduling):**  **为每个进程赋予一个优先级**，调度程序 **选择就绪队列中优先级最高的进程**  来分配 CPU。  非抢占式优先级调度中，一旦优先级最高的进程被选中执行，就会一直运行到结束或主动放弃 CPU。
  - **工作原理:** 每个进程都有一个优先级 (通常用整数表示，数值越大优先级越高或越低，取决于具体系统)。 调度程序维护一个就绪队列，每次选择优先级最高的进程执行。
  - **优点:** **可以根据进程的优先级来区分对待**，优先执行重要的、紧急的进程。 灵活性高，可以根据不同的优先级策略实现不同的调度效果。
  - **缺点:** **可能导致低优先级进程饥饿**，如果一直有高优先级进程到来，低优先级进程可能永远得不到执行机会。 **优先级反转问题**：当高优先级进程等待低优先级进程释放资源时，低优先级进程如果被其他中优先级进程抢占，会导致高优先级进程的等待时间更长。 **如何合理设置和动态调整进程优先级是一个复杂的问题。**
  - **适用场景:** **可以用于实时系统和批处理系统**，根据不同的优先级策略可以满足不同的调度需求。 例如，实时系统中，可以将实时进程设置为高优先级，保证其及时响应。

2. **抢占式调度 (Preemptive Scheduling):** 操作系统可以根据某种策略 **强制中断** 正在运行的进程，并将 CPU 分配给另一个进程。 抢占式调度可以更好地满足响应时间的要求，提高系统的公平性。

- **时间片轮转 (Round Robin, RR):**  **将 CPU 时间划分为固定大小的时间片 (Time Slice)**，每个进程被分配一个时间片。  进程在一个时间片内执行，时间片用完后，即使进程没有执行完，也会被 **强制剥夺 CPU**，并被放入就绪队列的队尾，等待下一次调度。  调度程序 **轮流**  为就绪队列中的进程分配时间片。
  - **工作原理:** 维护一个就绪队列，新到达的进程添加到队尾。 调度程序每次从队头选择进程，分配一个时间片给它执行。 时间片用完后，进程被移到队尾。 循环往复。
  - **优点:** **公平性好**，每个进程都能在一定时间内获得 CPU 时间。 **响应时间快**，适用于交互式系统。 实现相对简单。
  - **缺点:** **时间片大小的选择很重要**。 时间片太小，进程频繁切换，上下文切换开销增大，系统效率降低；时间片太大，RR 算法会退化为 FCFS 算法，响应时间变长。 **上下文切换开销相对较大。** **吞吐量相对较低。**
  - **适用场景:** **广泛应用于交互式分时系统**，例如，大多数通用操作系统 (如 Linux, Windows) 都使用 RR 算法的变体。 适用于需要快速响应的应用，例如，Web 服务器、终端交互等。
- **优先级调度 (Preemptive Priority Scheduling):**  **抢占式优先级调度**。  与非抢占式优先级调度类似，但增加了 **抢占机制**。  当一个更高优先级的进程到达就绪队列时，**正在运行的进程会被立即抢占**，CPU 被分配给新到达的高优先级进程。
  - **工作原理:** 每个进程都有优先级。 调度程序始终选择就绪队列中优先级最高的进程执行。 当有更高优先级进程到达时，立即抢占当前运行进程。
  - **优点:** **兼顾了优先级和响应时间**，可以优先保证高优先级进程的执行，同时也能保证一定的响应速度。 灵活性高，可以根据不同的优先级策略实现不同的调度效果。
  - **缺点:** **仍然可能导致低优先级进程饥饿**，虽然抢占机制在一定程度上缓解了饥饿问题，但如果高优先级进程持续不断地到来，低优先级进程仍然可能长时间得不到执行机会。 **优先级反转问题依然存在，需要更复杂的机制来解决 (例如，优先级继承、优先级天花板协议)。** **上下文切换开销相对较大。**
  - **适用场景:** **适用于实时系统和需要区分进程优先级的系统**。 例如，实时操作系统、嵌入式系统、网络设备等。
- **多级队列调度 (Multilevel Queue Scheduling):**  **将就绪队列分为多个独立的队列**，每个队列采用不同的调度算法。  例如，可以将就绪队列分为前台队列 (交互式进程) 和后台队列 (批处理进程)。  每个队列可以采用不同的优先级和调度算法，例如，前台队列使用 RR 算法，后台队列使用 FCFS 算法。  队列之间可以采用固定优先级调度 (例如，先调度优先级高的队列，只有当高优先级队列为空时，才调度低优先级队列) 或时间片轮转调度 (例如，每个队列分配一定比例的 CPU 时间)。
  - **工作原理:** 将就绪队列划分为多个队列，每个队列使用不同的调度算法和优先级。 队列之间也可能有优先级关系或时间片分配。 进程根据自身的属性 (例如，进程类型、优先级) 被分配到不同的队列。
  - **优点:** **灵活性高**，可以根据进程的类型和需求，采用不同的调度策略，更好地满足不同类型进程的调度需求。 **可以兼顾交互式进程和批处理进程的调度性能。**
  - **缺点:** **算法复杂性增加**，需要管理多个队列和队列之间的调度关系。 **进程的队列分配是静态的**，一旦进程被分配到一个队列，就不能轻易移动到其他队列，可能不够灵活。 **仍然可能存在低优先级队列中的进程饥饿问题。**
  - **适用场景:** **适用于需要区分不同类型进程的系统**，例如，同时运行交互式任务和批处理任务的通用操作系统。 可以根据进程的特点将进程分配到不同的队列进行调度。
- **多级反馈队列调度 (Multilevel Feedback Queue Scheduling, MFQ):**  是 **多级队列调度的一种改进**。  **允许进程在不同队列之间移动**，可以根据进程的 CPU 占用率和等待时间动态调整进程的优先级和所属队列。  试图 **兼顾短作业优先和时间片轮转的优点**，同时 **避免 SJF 算法需要预知进程运行时间和 RR 算法时间片大小选择的困难**。
  - **工作原理:** 设置多个就绪队列，每个队列优先级不同，时间片大小也不同 (优先级越高，时间片越小)。 新进程首先进入最高优先级队列的队尾。 进程在当前队列中按照 RR 算法执行，如果在一个时间片内没有完成，则被移到下一个优先级队列的队尾 (优先级降低，时间片增大)。 如果进程在所有队列中都没有完成，则最终会被移到最低优先级队列。 同时，为了防止低优先级队列中的进程饥饿，可能会设置 **队列提升机制**，例如，每隔一段时间将所有进程都提升到最高优先级队列。
  - **优点:** **性能较好，灵活性高**，可以动态调整进程的优先级和队列，**较好地兼顾了短进程和长进程，以及交互式进程和批处理进程的调度需求**。 **不需要预知进程的运行时间**，能够适应各种类型的进程负载。 **相对公平**，通过队列提升机制可以避免低优先级进程的永久饥饿。
  - **缺点:** **算法复杂性较高**，实现和调优比较困难。 **参数设置 (队列数量、时间片大小、队列优先级、队列提升策略等) 对性能影响较大**，需要根据具体系统和应用场景进行调整。
  - **适用场景:** **现代通用操作系统中常用的调度算法**，例如，Linux 的 CFS (Completely Fair Scheduler) 调度器就是 MFQ 算法的一种变体。 适用于各种类型的系统，尤其是需要兼顾交互性和吞吐量的通用系统。





## （4）你用过什么linux命令（我就说了ps -ef|grep xxx哈哈哈）





**5、数据库**

## （1）一般用什么数据结构作索引，为啥

B+树、B树、哈希、 **Sorted String Table (SSTable)** 



（2）实际项目中数据库的使用程度

（3）你知道乐观锁和悲观锁嘛

**6、算法题**

搜索旋转排序数组（lc原题）

### 二面 8月25日

1、问实习项目

**2、操作系统**

## （1）怎么创建进程/怎么运行sh文件/怎么创建后台进程（说了nohup，问了nohup和普通终端运行的区别）

**总结一下，创建新进程的典型流程是：**

1. **父进程调用 fork() 创建子进程。**
2. **子进程调用 exec() 族函数加载并执行新的程序。**
3. **父进程和子进程可以分别执行不同的任务。**



**shebang (#!) 行的作用：**

- **脚本文件的第一行通常以 #! 开头，后面跟着解释器程序的路径，例如 #!/bin/bash 或 #!/usr/bin/env python3。** 这被称为 "shebang" 或 "hashbang" 行。
- **当直接执行脚本文件 (例如 ./script.sh) 时，如果脚本文件有执行权限 (使用 chmod +x script.sh 添加执行权限)，操作系统会根据 shebang 行指定的解释器程序来执行脚本。** 例如，如果 shebang 行是 `#!/bin/bash`，则操作系统会使用 `/bin/bash` 解释器来执行 `script.sh`。
- **如果脚本文件没有 shebang 行，或者没有执行权限，则通常需要显式指定解释器来运行脚本，例如 bash script.sh。**



- **nohup 命令:**  `nohup` 命令可以使进程**忽略 SIGHUP 信号**，从而避免在终端关闭或用户退出登录时被终止。  通常与 `&` 符号一起使用，例如 `nohup command &> output.log &`。  `nohup` 还会将进程的标准输出和标准错误输出重定向到 `nohup.out` 文件 (默认情况下，如果当前目录可写)。
- **disown 命令:**  `disown` 命令可以将一个**正在运行的后台进程从当前的作业控制中移除**。  移除后，这个进程将**不再是当前 Shell 会话的子进程**，而是变成 init 进程 (PID 1) 的子进程。  这样即使关闭终端或退出登录，这个进程也会继续运行，并且不会收到 SIGHUP 信号。  `disown` 比 `nohup` 更彻底地将进程与终端分离。



## （2）怎么看进程的状态（具体信息）

ps, top, htop, pidstat, iostat, perf flamegraph



## （3）文件读写权限对应的数字（chmod，不会只知道777）

- **1. 用户 (User, u):** 指**文件或目录的所有者 (owner)**。 每个文件和目录都属于一个特定的用户，这个用户就是所有者。
- **2. 组 (Group, g):** 指**文件或目录所属的组 (group)**。 每个文件和目录也属于一个特定的组，这个组通常是创建文件或目录的用户的所属组。
- **3. 其他 (Others, o):** 指**既不是文件所有者，也不是文件所属组成员的其他用户**。 也就是除了 User 和 Group 之外的所有用户。



## （4）你知道父进程和子进程嘛？fork()？



**3、计算机网络**

## （1）http状态码（304不会）

`HTTP 状态码 304 Not Modified` 的字面意思是 **“未修改”**。  它的核心含义是：

**服务器告知客户端，所请求的资源自客户端上次请求后，资源本身并没有发生任何修改。  因此，客户端可以使用本地缓存的资源副本，而无需重新下载完整资源。**

简单来说，`304` 状态码就是服务器对客户端发出的 **“你的缓存还是最新的，直接用缓存吧！”** 的信号。



**关键点：**

- **未修改 (Not Modified):** 强调的是资源本身的内容没有变化。
- **使用缓存副本:** 客户端应该使用之前缓存的资源副本，而不是服务器返回的空响应体。
- **条件请求 (Conditional Request):** `304` 状态码通常是**客户端发起条件 GET 请求**后，服务器的响应结果。 条件请求是指客户端在请求头中携带一些条件信息，例如上次修改时间或实体标签 (ETag)，让服务器根据这些条件判断资源是否需要更新。



## （2）301和302的区别

301永久重定向，302临时重定向



## （3）cookie和session的区别





**4、数据库**

（1）怎么给已经建好的表的字段创建索引（不会）

（2）你了解数据库的什么东西？（说了索引和事务）

（3）事务是怎么实现的？（应该说日志的….）

（4）事务里对哪些数据上锁

（5）数据库删表的方式（delete和truncate的区别，不会）

（6）数据库乐观锁的实现

**5、算法题**

寻找走到右下角的可行路径，并输出路径结果，有障碍物，四个方向都能走。

### 三面 8月27日

1、问实习项目

2、对自己的评价？

3、base的倾向？

4、将来的发展规划？

5、算法题：最短路径和，直接牛客上的输入输出。

6、反问环节

#### hr面 9月1日

1、问实习

（1）为什么没转正

（2）实习做了什么

（3）实习的难点是什么

（4）平时会跟mentor沟通嘛

（5）从同事那里学到了什么

（6）会做复盘嘛？

2、问未来规划

3、问会自己去学习一些什么技术嘛

4、问哪里人，base倾向

5、有家人在腾讯工作嘛？爸妈是干嘛的？爸妈支持你的工作嘛

6、问实习部门的工作强度，对加班怎么看（暗示加班咯）

7、问还有啥别的公司在流程中

反问：

1、顺利的话之后要多久出结果，答3~5个工作日

2、工作强度，答目前有很大的发挥空间，不如其他电商产品那么成熟细致，分工明确

我相信tx是爱我的！