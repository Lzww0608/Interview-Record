# PCG腾讯看点20250108

### 一面（2021-3-5 用时 35min ）

## 自我介绍



## 进程、线程和协程间的概念和区别

**区别总结**

| 特性           | 进程 (Process)                   | 线程 (Thread)                              | 协程 (Coroutine)                       |
| -------------- | -------------------------------- | ------------------------------------------ | -------------------------------------- |
| **资源分配**   | 操作系统分配资源的基本单位       | 操作系统调度的基本单位，共享进程资源       | 用户程序控制调度，共享线程资源         |
| **内存空间**   | 独立的内存空间                   | 共享所属进程的内存空间                     | 共享所属线程的内存空间                 |
| **切换开销**   | 高 (需要操作系统内核切换)        | 中等 (需要操作系统内核切换)                | 低 (用户态切换)                        |
| **并发方式**   | 并行 (多核) 或并发 (单核)        | 并行 (多核) 或并发 (单核)                  | 并发 (单线程内)                        |
| **通信方式**   | IPC (管道、消息队列、共享内存等) | 共享内存 (需同步机制)                      | 共享内存 (通常无需复杂同步)            |
| **所有者**     | 操作系统                         | 所属进程                                   | 所属线程或程序                         |
| **编程模型**   | 多进程编程                       | 多线程编程                                 | 异步编程、事件驱动编程                 |
| **稳定性**     | 高，一个进程崩溃不影响其他进程   | 相对较低，一个线程崩溃可能导致整个进程崩溃 | 相对较高，一个协程阻塞不会阻塞其他协程 |
| **上下文切换** | 上下文切换包括寄存器、内存映射等 | 上下文切换主要包括寄存器、堆栈等           | 上下文切换仅需保存和恢复少量上下文     |



## IO 密集型和 CPU 密集型如何分配线程优先级

- **让 I/O 密集型任务优先：** 因为它们大部分时间在等待 I/O 操作完成（例如，等待网络响应、磁盘读取等），占用 CPU 的时间相对较少。给予它们更高的优先级可以确保在 I/O 操作完成后，它们能迅速获得 CPU 时间继续处理数据，从而提高整体效率。
- **让 CPU 密集型任务较低优先级：** 因为它们会长时间占用 CPU 进行计算。如果给予它们过高的优先级，可能会导致 I/O 密集型任务得不到及时的 CPU 时间，从而降低系统的响应速度和整体吞吐量。



## 无锁编程（答了 CAS

1. 原子操作：读、写，CAS， fetch-and-add
2. CAS自旋锁
3. RCU(read copy update)，`sycn.Map`
4. hazard pointers

**CAS注意ABA问题**： 增加tag（如版本号），



## select 和 epoll 的区别

| 特性           | select                                           | epoll                                                |
| -------------- | ------------------------------------------------ | ---------------------------------------------------- |
| **工作机制**   | 轮询 (Polling)                                   | 事件通知 (Event-driven)                              |
| **性能**       | 随着监听的 FD 数量增加，性能线性下降 (O(n))      | 性能不会随着监听的 FD 数量增加而显著下降 (近似 O(1)) |
| **最大连接数** | 受限于 FD_SETSIZE 宏定义 (通常为 1024)           | 没有最大连接数限制，只受限于系统资源                 |
| **通知方式**   | 返回所有就绪的 FD 集合，需要用户空间遍历         | 只返回活跃的 FD 列表，无需遍历                       |
| **回调机制**   | 无内置回调机制                                   | 可以使用边缘触发 (ET) 和水平触发 (LT) 模式           |
| **数据复制**   | 每次调用都需要将 FD 集合从用户空间拷贝到内核空间 | 只需注册一次 FD，减少数据拷贝                        |
| **API 使用**   | 每次循环都需要重新设置监听的 FD 集合             | 只需注册一次，后续只需监听事件                       |
| **线程安全性** | 通常不是线程安全的，需要额外同步机制             | 在多线程环境下使用需要注意线程安全问题               |
| **平台支持**   | 大部分 Unix-like 系统支持                        | Linux 特有                                           |



## go 语言的 panic 如何恢复

`defer`



## 有对项目和系统做性能测试吗？(benchmark 和 pprodf)



## go 中 new 和 make 的区别

1. `new` 返回的是指针，`make`返回的是对象
2. 只有`map` `channel` 切片可以 `make`

## 项目，jwt 是什么

用户鉴权

## sql 执行慢，是什么原因，怎么解决



## 以前的实习经历



## 二叉树的最近公共祖先

LCA

## 寻找两个正序数组的中位数

双指针

## 智力题：一只猴子，50根香蕉，距离家 25米，猴子一次最多能拿 25 根香蕉，每走一米需要吃掉一根香蕉，请问最多能带多少根香蕉回家



## 插入排序的时间复杂度，快排呢？



### 二面 （2021-3-10 用时 30min ）

## 算法题：快排思路找topK



## 场景题：两堆大数，100亿个数和10亿个数，找交集

1. 归并排序，双指针查找
2. 哈希分桶（写入如.txt文件中） + 布隆过滤器



## 场景题：直播房间，一个大V发了一条消息，如何让上千万的粉丝收到这条消息，如果只是纯粹的广播会很耗资源

**方案一：基于发布/订阅模式 (Pub/Sub) 的消息队列**

这是最常用且推荐的方案。

- **技术选型:** Kafka, RabbitMQ, Redis Pub/Sub 等。
- **流程:**
  1. **大V发布消息:** 大V将消息发送到消息队列的特定主题 (Topic)，例如以大V的ID或用户名作为主题。
  2. **消息队列存储:** 消息队列持久化存储消息，确保消息不丢失。
  3. **粉丝订阅主题:** 每个粉丝的客户端都订阅了大V对应的主题。
  4. **消息推送/拉取:** 消息队列将消息推送给订阅了该主题的客户端，或者客户端主动从消息队列拉取消息。
- **优点:**
  - **异步处理:** 大V发送消息后无需等待所有粉丝接收，提高了发送效率。
  - **解耦:** 发送者和接收者之间没有直接依赖。
  - **可扩展性:** 消息队列本身易于扩展，可以处理大量的并发连接和消息。
  - **消息持久化:** 确保消息的可靠性。
- **缺点:**
  - **需要额外的消息队列系统:** 需要部署和维护消息队列集群。
  - **可能存在一定的延迟:** 消息从发送到接收可能会有毫秒级的延迟，对于实时性要求极高的场景需要优化

**方案二：基于分布式缓存 + 推送**

- **技术选型:** Redis, Memcached 等分布式缓存，配合推送服务 (例如 WebSocket, Server-Sent Events)。
- **流程:**
  1. **大V发布消息:** 大V将消息发送到后端服务器。
  2. **后端写入缓存:** 后端服务器将消息写入分布式缓存中，可以以大V的ID作为 key，消息内容作为 value。
  3. **推送服务通知:** 后端服务器通过推送服务 (例如 WebSocket) 通知所有在线的粉丝客户端有新消息。
  4. **客户端拉取:** 客户端收到通知后，根据大V的 ID 从分布式缓存中拉取消息。
- **优点:**
  - **读取速度快:** 从缓存中读取消息速度非常快。
  - **减少对数据库的压力:** 大部分消息读取操作都在缓存层完成。
- **缺点:**
  - **缓存失效问题:** 需要考虑缓存失效策略，避免数据不一致。
  - **推送服务的压力:** 推送服务需要处理大量的并发连接。
  - **可能存在消息丢失:** 如果推送失败，需要有重试机制。



## select 和 epoll 的差别



## C 和 C++ 的字节对齐



## 问学习和生活等个人信息



### hr 面 （2021-3-17 用时 40min )

自我介绍

实习经历，实习的具体，实习的时候学到了什么，印象最深刻的是什么，有什么遗憾

怎么学习新技术的

之前的面试官有和你说腾讯看点的业务吗？你说下你怎么理解的

你投了什么其他公司吗？对offer 的期望是什么样的？

你期望的实习是怎么样的

反问：问了对实习生是怎么培养的：mentor 一对一，78月份表现好可以实习留用转正答辩