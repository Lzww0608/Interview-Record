# 百度Go实习一面

项目相关
1、分布式一致性是什么？
2、介绍一下raft协议
3、负载均衡如何实现
八股
4、介绍数据库和MySQL
5、MySQL框架
6、MySQL查一条数据的过程

7、MySQL数据落盘的过程

8、介绍索引的机制

#### 1. 加速查询的原理
- **全表扫描 vs 索引扫描**：
  - **无索引**：查询时需逐行扫描所有数据（时间复杂度 O(N)）。
  - **有索引**：通过 B+树快速定位到目标数据（时间复杂度 O(log N)）。
- **示例**：  
  对 `WHERE age = 25` 的查询，若 `age` 字段有索引，数据库会从根节点开始逐层比较，最终定位到叶子节点中的 `age=25` 记录。
#### 2. 索引的存储方式
- **聚集索引（Clustered Index）**：
  - 叶子节点直接存储完整的数据行（InnoDB 的主键索引即聚集索引）。
  - **一张表只能有一个聚集索引**。
- **非聚集索引（Secondary Index）**：
  - 叶子节点存储主键值（非数据行），需要回表查询（通过主键二次查找数据）。
  - **一张表可以有多个非聚集索引**。
#### 3. 索引的维护代价
- **写操作成本**：插入、更新、删除数据时需同步维护索引结构（B+树的平衡）。
- **存储成本**：索引占用额外的磁盘空间。



9、什么时候用索引、什么时候不用索引

**适合使用索引的场景：**

1. **高选择性查询条件**
   - 当WHERE条件的列具有高选择性(cardinality高)时，如主键、唯一键查询。
   - 例如：`SELECT * FROM users WHERE id = 10;`

2. **排序和分组操作**
   - 当需要对结果排序(ORDER BY)或分组(GROUP BY)时，索引可以避免额外的排序操作。
   - 例如：`SELECT * FROM orders ORDER BY create_time DESC LIMIT 10;`

3. **联表查询的连接字段**
   - JOIN操作中的连接字段应该建立索引，避免全表扫描。
   - 例如：`SELECT * FROM orders o JOIN users u ON o.user_id = u.id;`

4. **覆盖索引查询**
   - 当查询的所有字段都包含在索引中，可以直接从索引获取数据而无需回表。
   - 例如：对(name, age)建立联合索引时执行`SELECT name, age FROM users WHERE name = 'John';`

**不适合使用索引的场景：**

1. **低选择性的列**
   - 当列的不同值较少时(如性别、状态字段)，索引的效果有限。
   - 例如：`SELECT * FROM users WHERE gender = 'male';`（如果大部分用户都是男性）

2. **频繁更新的列**
   - 索引会增加写操作的开销，对于频繁更新的列应谨慎索引。
   - 例如：频繁更新的计数器字段或状态字段。

3. **小表查询**
   - 对于记录数很少的表，全表扫描可能比使用索引更快。
   - 例如：只有几百条记录的配置表。

4. **索引失效的情况**
   - 使用函数操作索引列：`SELECT * FROM users WHERE YEAR(birth_date) = 1990;`
   - 隐式类型转换：`SELECT * FROM users WHERE age = '30';`（age为整型）
   - 前缀模糊匹配：`SELECT * FROM users WHERE name LIKE '%Smith';`
   - OR条件连接不同索引列：`SELECT * FROM users WHERE name = 'John' OR age = 30;`



10、什么时候回表

11、介绍事务

12、redo log 和bin log 区别

| 特性         | Redo Log (重做日志)               | Binlog (归档日志/二进制日志)               |
| ------------ | --------------------------------- | ------------------------------------------ |
| **主要目的** | 保证事务持久性和原子性 (崩溃恢复) | 数据复制、备份、时间点恢复、审计           |
| **记录内容** | 物理层面的数据页修改 (如何修改)   | 逻辑层面的操作 (SQL 语句或行变更 - 做什么) |
| **作用范围** | 实例级别 (Instance-Level)         | 服务器级别 (Server-Level)                  |
| **持久性**   | 高持久性 (事务提交前写入)         | 相对持久性 (事务提交后写入)                |
| **主要用途** | 崩溃恢复，事务回滚 (辅助)         | 主从复制，时间点恢复，数据审计，数据分析   |
| **格式**     | 物理格式 (二进制)                 | 逻辑格式 (Statement/Row/Mixed)             |
| **写入方式** | 循环写入 (Circular)               | 追加写入 (Append-Only)                     |



13、没有redo log 或没有 bin log会发生什么

| 特性           | 没有 Redo Log                                            | 没有 Binlog                                            |
| -------------- | -------------------------------------------------------- | ------------------------------------------------------ |
| **最主要影响** | **数据丢失！已提交事务可能丢失！ Durability 无法保证！** | **功能受限！复制、时间点恢复、审计等功能受损！**       |
| **可靠性**     | **极低！数据极易丢失，系统不可靠！**                     | **降低！可靠性降低，但基本功能还能运行 (单机)**        |
| **功能性**     | 基本功能都可能不稳定，因为数据一致性无法保证。           | 功能性受限，高级功能缺失，灵活性降低。                 |
| **后果严重性** | **灾难性！生产环境绝对不能没有 Redo Log！**              | 严重！生产环境不建议没有 Binlog (除非极特殊场景)       |
| **比喻**       | 像盖房子没有地基，随时可能倒塌。                         | 像汽车没有导航、倒车影像等辅助功能，还能开，但体验差。 |

14、MySQL什么情况存在主从延迟问题

**1. 主库 (Master) 写入压力过大:**

* **高并发写入操作:** 当主库接收到大量的写操作 (INSERT, UPDATE, DELETE) 时，生成 Binlog 的速度会加快。如果从库的消费速度跟不上主库产生 Binlog 的速度，就会产生延迟。
* **大事务 (Large Transactions):**  如果主库执行了包含大量操作的大事务，这些操作会一次性写入 Binlog，导致从库需要花费更长时间来应用这些变更。
* **执行耗时长的 SQL 查询:**  主库上执行耗时长的 SQL 查询 (例如复杂的查询、全表扫描) 虽然不直接影响 Binlog 生成速度，但会消耗主库资源，间接影响整体性能，从而可能导致延迟。

**2. 从库 (Slave) 应用 Binlog 速度慢:**

* **SQL 线程瓶颈 (单线程复制的限制):**  在 MySQL 5.5 及更早版本中，复制是单线程的。这意味着从库只有一个 SQL 线程负责读取 Relay Log (从库接收到的 Binlog) 并应用到从库数据库。 如果主库写入压力大，或者从库应用 SQL 的速度慢，单线程很容易成为瓶颈。 **(MySQL 5.6 引入了多线程复制，但默认仍是单线程，MySQL 5.7 及更高版本默认支持基于库的多线程复制，MySQL 8.0 引入了更细粒度的逻辑时钟复制，进一步提升并行度)**。即使在多线程复制下，如果某些操作是串行化的（例如在同一个库上频繁更新同一行），仍然可能出现瓶颈。
* **从库自身性能瓶颈:**
    * **硬件资源不足:** 从库的 CPU、内存、磁盘 I/O 性能如果低于主库，或者资源利用率已经很高，那么应用 Binlog 的速度就会受到限制。
    * **从库 SQL 查询慢:**  从库在应用 Binlog 时，需要执行 SQL 语句。 如果从库本身存在慢查询，或者表结构设计不合理，索引缺失等问题，会导致应用 Binlog 速度变慢。
    * **从库维护操作:**  如果在从库上执行 DDL (数据定义语言，例如 `ALTER TABLE`) 操作、全量备份、或者其他维护操作，会占用从库资源，影响 Binlog 应用速度。
* **从库配置不当:**
    * **`sync_binlog` 参数设置过低:**  `sync_binlog` 参数控制 Binlog 刷写磁盘的频率。 如果设置过低 (例如 0)，虽然可以提高主库写入性能，但也可能导致数据丢失风险，并且可能间接影响从库复制的稳定性。 (这个参数主要影响主库，但间接影响整体复制环境)
    * **`innodb_flush_log_at_trx_commit` 参数设置过低:** 这个参数控制 Redo Log 刷写磁盘的频率。 如果设置过低 (例如 0 或 1)，虽然可以提高主库写入性能，但也可能导致数据丢失风险，并且可能间接影响从库复制的稳定性。 (这个参数主要影响主库，但间接影响整体复制环境)
    * **`relay_log_info_repository` 和 `relay_log_relay_repository` 设置为 `TABLE`:**  将 Relay Log 元数据和 Relay Log 存储在表中会带来额外的 I/O 开销，可能会降低复制性能。 推荐使用 `FILE` 模式。

**3. 网络延迟:**

* **主从服务器之间的网络延迟和带宽限制:**  主库需要将 Binlog 通过网络传输到从库。 如果主从服务器之间的网络延迟较高，或者带宽不足，Binlog 传输就会受到影响，导致延迟。  尤其是在跨地域、跨机房的复制场景下，网络延迟的影响会更加明显。
* **网络抖动或不稳定:**  网络连接不稳定，频繁出现丢包或断连，也会导致复制中断或延迟。

**4. 复制格式 (Binlog Format) 选择不当:**

* **Statement-Based Replication (SBR):**  如果使用 SBR 格式，主库记录的是 SQL 语句。 从库需要重新执行这些 SQL 语句。 如果 SQL 语句中包含不确定的函数 (例如 `NOW()`, `RAND()`)，或者存储过程、触发器等，可能会导致主从数据不一致，或者应用时出现问题，从而间接导致延迟。  **Row-Based Replication (RBR) 和 Mixed-Based Replication (MBR) 在数据一致性方面通常更可靠，也更适合高并发写入场景。**

**5. 大 DDL 操作:**

* **大型 Schema 变更 (DDL):**  例如 `ALTER TABLE` 操作，特别是在大表上执行 DDL 操作时，会非常耗时，并且可能阻塞复制通道。  在 DDL 执行期间，复制可能会被暂停或延迟。  在线 DDL 工具 (如 pt-online-schema-change) 可以减少 DDL 操作对复制的影响，但仍然可能产生延迟。

**6. 长时间运行的查询或锁:**

* **主库长时间运行的查询或锁:**  如果主库上存在长时间运行的查询，或者某些操作持有长时间的锁 (例如表锁)，可能会阻塞 Binlog 的生成或传输，从而导致延迟。

**7. 从库版本低于主库版本 (有时):**

* **版本兼容性问题 (少见但可能):**  在某些情况下，如果从库的版本低于主库版本，可能存在兼容性问题，导致复制异常或延迟。 建议主从库版本保持一致或从库版本高于主库版本。

**8. 初始化复制时的数据量过大:**

* **初始同步 (Initial Synchronization) 延迟:**  在配置主从复制初期，如果主库数据量很大，初始全量同步过程会比较耗时。 在全量同步完成后，增量同步阶段也可能因为大量数据需要传输而出现一段时间的延迟。

15、C++和golang区别
手撕：最大连续子数组
闲聊
未来的方向