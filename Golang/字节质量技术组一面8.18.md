# 字节质量技术组一面 8.18

## 1、如果一段SQL执行缓慢，你该如何排查？

### 1. **查看执行计划（EXPLAIN）**

- 使用 `EXPLAIN` 或 `EXPLAIN ANALYZE` 查看 SQL 的执行计划，分析 SQL 语句的执行步骤，看看是否有表扫描（Full Table Scan）、索引使用不当、或者不合理的连接顺序等问题。例如：

```sql
EXPLAIN SELECT * FROM orders WHERE customer_id = 123;
```

### 2. **检查索引**

- 检查相关表的索引情况，确认查询条件中的列是否有合适的索引。
- 检查索引是否被正确使用，尤其是在 WHERE、JOIN、ORDER BY 和 GROUP BY 子句中。

```sql
SHOW INDEX FROM orders;
```

### 3. **分析表统计信息**

- 确保表的统计信息（Statistics）是最新的。可以通过运行 `ANALYZE TABLE` 或者数据库自动统计功能来更新统计信息。数据库通常根据这些统计信息来决定执行计划。

```sql
ANALYZE TABLE orders;
```

### 4. **优化查询**

- **简化查询**：尝试简化查询，拆分复杂的 SQL，或者分步执行以减少开销。
- **避免子查询**：有时将子查询改写为 JOIN 或者使用临时表会提高性能。
- **减少 SELECT \* 的使用**：仅选择需要的列，而不是使用 `SELECT *`。
- **WHERE 条件优化**：确保 WHERE 子句尽可能早地过滤数据，减少参与后续操作的数据量。

### 5. **检查数据库服务器资源**

- **检查系统资源**：CPU、内存、磁盘 I/O 和网络带宽是否存在瓶颈。

```sql
SHOW FULL PROCESSLIST;
```

- **锁争用**：查看是否有锁争用情况，可能导致 SQL 等待资源。
- **慢查询日志**：检查慢查询日志，分析是否存在其他系统级的瓶颈或数据库配置问题。

```sql
SET GLOBAL slow_query_log = 'ON';
SET GLOBAL long_query_time = 1; -- 记录执行时间超过1秒的查询
SHOW VARIABLES LIKE 'slow_query_log_file'; --查看慢查询日志的位置
```

### 6. **调整数据库配置**

- **缓冲区大小**：调整数据库的缓存和缓冲区大小，如 InnoDB 的 buffer pool size，PostgreSQL 的 shared buffers 等。
- **并发连接数**：检查并发连接数设置是否合理。
- **临时表空间**：增加临时表空间的大小或者将其移动到更快的存储设备。

### 7. **缓存和持久化策略**

- 可以利用缓存机制（如 Redis、Memcached）缓存频繁访问的数据，减少数据库的负担。
- 考虑使用物化视图（Materialized View）来存储复杂查询的结果，减少每次查询的计算量。



## 2、MySql有哪些索引类型？

**1. B-Tree 索引**：

- **描述**：这是 MySQL 中最常见的索引类型。大多数 MySQL 存储引擎（如 InnoDB 和 MyISAM）都支持 B-Tree 索引。
- **应用场景**：适用于全键值、键值范围查找和前缀查找。对于`ORDER BY`、`GROUP BY`和范围查询（如`BETWEEN`、`>`, `<`等）非常高效。
- **前缀索引 (Prefix Index)**：
  - **描述**：可以对字符串列的前几个字符创建索引，而不是整个字符串。减少索引大小，节省空间。
  - **应用场景**：适用于需要索引长字符串但不需要完整索引的场景，例如只需索引前几字符的URL。
- **复合索引 (Composite Index)**：
  - **描述**：复合索引是将多个列组合在一起形成的索引。
  - **应用场景**：当查询条件涉及多个列时，使用复合索引可以提高查询效率。复合索引中的列顺序非常重要，查询必须符合索引的列顺序才能充分利用索引。

**2. Hash 索引**：

- **描述**：使用哈希表实现的索引，只能用于精确查找，不支持范围查找。
- **应用场景**：适用于精确匹配的查询。典型的应用场景是 `MEMORY` 存储引擎的表，或者 InnoDB 引擎的唯一哈希索引（adaptive hash index）。

**3. 全文索引 (Full-Text Index)**：

- **描述**：全文索引用于对文本字段进行全文搜索，在 MySQL 中支持 InnoDB 和 MyISAM 引擎。
- **应用场景**：适用于对大文本字段进行关键词查询，像`MATCH...AGAINST`语句中的全文搜索。

**4. 空间索引 (Spatial Index)**：

- **描述**：空间索引用于处理GIS（地理信息系统）数据的存储和查询，采用 R-Tree 数据结构。
- **应用场景**：适用于 MySQL 中的`Geometry`类型数据，用于处理地理数据的空间查询。





## 3、MySQL有哪几个数据库引擎，它们的主要区别是什么？

### 1. **InnoDB**

- **事务支持**：InnoDB 支持 ACID 事务，因此能够确保数据的可靠性和一致性。支持回滚、提交和崩溃恢复功能。
- **外键支持**：InnoDB 是 MySQL 中唯一支持外键约束的引擎，允许定义外键关系来保证数据完整性。
- **锁机制**：使用行级锁（Row-level locking），因此在高并发环境下表现良好，减少了锁冲突。
- **崩溃恢复**：InnoDB 使用日志文件来记录未完成的事务，以便在数据库崩溃时能够恢复。
- **适用场景**：适用于需要高可靠性、高并发写操作和复杂查询的应用，如金融系统、电商平台等。

### 2. **MyISAM**

- **事务支持**：MyISAM 不支持事务处理，因此不适用于需要数据一致性的关键应用。

- **外键支持**：不支持外键约束，数据完整性需要通过应用程序层来维护。

- **锁机制**：使用表级锁（Table-level locking），在写入操作较多的环境下，可能会导致较高的锁争用。

- **速度**：在读操作频繁、数据不经常更改的场景下，MyISAM 的查询速度比 InnoDB 快。

  - MyISAM 在读操作频繁、数据不经常更改的场景下查询速度比 InnoDB 快的主要原因可以归结为以下几点：

    #### 1. **表级锁（Table-level Locking）**

    MyISAM 使用表级锁定机制，这意味着当进行读或写操作时，整个表会被锁定。这种锁定机制在读操作频繁且数据较少更新的场景下能够非常高效，因为：

    - **锁开销低**：相比 InnoDB 的行级锁，表级锁的开销更低。当只有读操作时，MyISAM 的锁定机制非常简单，因此性能较高。
    - **并发性**：虽然表级锁在写操作频繁时会影响并发性，但在大量读操作的场景下，不存在锁争用的情况，查询性能优异。

    #### 2. **存储结构简单**

    MyISAM 的存储结构相对 InnoDB 更为简单：

    - **数据和索引存储**：MyISAM 将数据和索引分别存储在不同的文件中，这样的结构使得在执行纯粹的读取操作时，可以更快速地访问数据。
    - **不支持事务**：MyISAM 不支持事务处理，这意味着不需要维护事务日志或处理回滚和提交操作，这减少了磁盘 I/O 和 CPU 开销。

    3. **较小的存储开销**

    MyISAM 相比 InnoDB，数据存储效率较高，占用的磁盘空间更小。这种紧凑的存储方式意味着在相同硬件条件下，MyISAM 可以加载更多的数据到内存中，从而提高查询速度。

    #### 4. **全文索引（Full-Text Search）**

    MyISAM 支持内建的全文索引，特别适合文本搜索的场景。在涉及大量文本数据的查询中，MyISAM 的全文索引可以显著提高查询性能，而 InnoDB 直到后来的版本才引入了全文索引功能。

    #### 5. **无外键约束**

    MyISAM 不支持外键约束，减少了维护关系完整性的开销。在没有外键关系或关系维护由应用程序管理的情况下，MyISAM 不需要进行额外的关系完整性检查，因此执行查询的速度更快。

- **适用场景**：适用于读操作较多的应用，如数据仓库、日志记录等。

### 3. **Memory**

- **存储位置**：数据存储在内存中，因此读写速度非常快，但在服务器关闭时数据会丢失。
- **锁机制**：使用表级锁。
- **数据持久性**：不提供数据持久化，适用于需要高速访问临时数据的场景。
- **适用场景**：适用于需要快速访问临时数据的场景，如临时表、缓存等。

### 4. **CSV**

- **存储格式**：数据以 CSV 文件的形式存储在磁盘上，每个表对应一个 CSV 文件。
- **速度**：由于没有索引支持，数据查询速度较慢。
- **兼容性**：适用于需要与外部程序（如 Excel）交换数据的场景。
- **适用场景**：适用于需要简单数据导入/导出功能的应用场景。

### 5. **其他引擎**

- **Aria**：类似 MyISAM，但更为可靠，支持崩溃恢复，通常用于 MariaDB。
- **Federated**：用于访问远程 MySQL 数据库中的表，通过 MySQL 服务器之间的连接，实现跨服务器的分布式数据库。
- **Archive**：用于存储大量的归档数据，主要用于插入和查询操作，不支持索引，适用于存储日志数据。

### 总结

- **InnoDB** 是默认且最常用的引擎，适用于绝大多数应用场景，尤其是那些需要事务支持和数据一致性的场景。
- **MyISAM** 适用于读操作频繁且不要求事务处理的应用。
- **Memory** 适用于需要快速访问的临时数据。
- **CSV** 适用于与外部系统进行数据交换的场景。



## 4、悲观锁和乐观锁的区别？

### 1. 悲观锁（Pessimistic Lock）

- **实现方式：** 在对数据进行读或写之前，先对数据进行加锁，阻止其他事务或线程对数据的访问，直到当前操作完成并释放锁。
- **场景：** 悲观锁通常用于写操作多、冲突概率高的场景。典型的例子包括数据库中的行锁（Row Lock），在事务开始时对要访问的行加锁，直到事务结束才释放。
- **优点：** 确保数据的一致性，避免了冲突和死锁（通过严格控制锁的顺序）。
- **缺点：** 可能导致性能瓶颈，因为其他操作可能会因为锁的存在而被阻塞，尤其是在冲突很少发生的情况下，这种锁机制会带来不必要的开销。

### 2. 乐观锁（Optimistic Lock）

- **实现方式：** 在更新数据时，不直接加锁，而是在提交时检查数据是否被其他事务或线程修改过。通常通过“版本号”或“时间戳”等机制实现。如果发现数据已经被修改，则操作失败，重新尝试。
- **场景：** 乐观锁通常用于读操作多、冲突概率低的场景。例如，在版本控制系统或数据库的CAS（Compare and Swap）操作中，常用乐观锁来确保数据的一致性。
- **优点：** 不需要加锁，大大减少了因锁引起的性能开销，更适合读多写少的场景。
- **缺点：** 如果冲突频繁，乐观锁的重试机制会导致性能下降，并增加系统开销。



## 5、Redis为什么快？

首先，需要明确，Redis只有`redis-server`是单线程的，指所有的命令处理流程在一个线程中处理。

1. Redis是内存数据库，所有操作都是基于内存的， 不是CPU密集型的。
2. 数据结构高效，不同的对象类型有不同的具体实现。
   - string：
     - int
     - raw
     - embstr
   - list: quicklist, 节点采用ziplist
   - hash:
     - ziplist
     - dict
   - set:
     - intset
     - dict
   - zset:
     - ziplist
     - **skiplist**
3. 如果是多线程，那么就需要加锁，Redis中sds, list, hash, set, zset都有多种不同的实现，因此锁的粒度不好控制同时会导致CPU频繁的上下文切换。
4. 对于网络连接，实际上采用的是Reactor网络模型，多路IO复用，非阻塞IO。
5. 单线程所作的优化（**耗时阻塞的操作，另起线程处理**）：
   - 异步关闭大文件 `bio-close-file`
   - 异步释放大内存 `bio-lasy-free`
   - 异步AOF刷盘 `bio-aof-fasync`
   - 内存池分配 `jemalloc-bg-threads`
   - IO多线程 `io-threads` read/write/decode/encode
   - 将大操作拆分成小操作
     - 渐进式rehash： ①分散在每一步操作中，移动一个 ②空闲时，rehash 1ms
   - 根据对象选择不同的数据结构
     - 根据节点的数量动态选择数据结构
     - 在时间和空间上进行均衡



## 6、Redis如何保证断电后数据不会丢失？如何做到数据高可用且避免不一致问题？

### 1. 数据持久化

Redis 提供了两种持久化方式来保证断电后数据不会丢失：

#### 1.1. RDB（Redis Database Backup）

- **机制：** Redis会在特定的时间间隔内将内存中的数据快照保存到磁盘中，生成一个 `.rdb` 文件。这个文件包含了某个时间点的数据快照。
- **优点：** RDB 生成的文件非常紧凑，适合备份和恢复时使用，恢复速度较快。
- **缺点：** 因为 RDB 是定时保存数据快照，所以在系统崩溃时，可能会丢失最近一次快照后的所有数据。

#### 1.2. AOF（Append Only File）

- **机制：** AOF 以日志的形式记录每个写操作，并将这些操作依次追加到文件中。Redis 提供了三种不同的同步策略：每次写操作后同步（appendfsync always）、每秒同步一次（appendfsync everysec）、从不同步（appendfsync no）。
- **优点：** AOF 提供了更高的数据安全性，因为它可以记录每个写操作，可以避免数据丢失。
- **缺点：** AOF 文件通常比 RDB 文件大，而且恢复速度相对较慢。
- **AOF 重写机制：** 由于 AOF 文件不断增长，Redis 提供了 AOF 重写机制，定期将 AOF 文件压缩为一个新的文件，以减少文件大小和恢复时间。

### 2. 数据高可用性和一致性

为了实现数据的高可用性并避免不一致问题，Redis通常采用以下策略：

#### 2.1. 主从复制（Replication）

- **机制：** Redis 支持主从复制，一个 Redis 服务器（主节点）可以有多个从节点。主节点处理写操作，并将数据同步到从节点。从节点可以处理读请求，这样就可以提高读性能。
- **数据同步：** 初次复制时，从节点会进行一次全量复制，之后主节点只将写操作的命令流发送给从节点，实现增量同步。
- **高可用性：** 如果主节点故障，可以手动或通过工具将某个从节点提升为新的主节点，从而继续提供服务。

#### 2.2. 哨兵模式（Sentinel）

- **机制：** Redis 哨兵（Sentinel）是一个用于监控 Redis 主从实例的高可用性解决方案。Sentinel 可以自动执行主从切换，当主节点不可用时，会自动将一个从节点提升为主节点，并通知客户端更新连接信息。
- **优势：** Sentinel 提供了自动故障转移、主从切换、通知等功能，确保 Redis 集群的高可用性。

#### 2.3. Redis 集群（Cluster）

- **机制：** Redis 集群通过数据分片（Sharding）来将数据分布在多个节点上。每个节点负责存储一部分数据，并且每个节点都有一到多个从节点来保证高可用性。
- **一致性保障：** Redis 集群使用一致性哈希算法来分配数据，并且使用 Gossip 协议来节点间交换状态信息。为了防止脑裂现象，集群中需要多数派（majority）投票才能进行主从切换，从而避免数据不一致。
- **故障转移：** 如果某个主节点失败，集群会自动选举其中一个从节点作为新的主节点，从而实现自动故障恢复。





## 7、缓存雪崩、击穿、穿透和解决办法？

### 缓存穿透（Cache Penetration）：Redis和MySQL中都没有

> 缓存穿透是指在缓存系统中，某些查询由于没有命中缓存而直接访问底层数据库，导致数据库压力增大的问题。具体来说，缓存穿透发生在当请求的数据在缓存和数据库中都不存在时，所有请求都会穿透缓存直接访问数据库，从而使得缓存失去了其减少数据库访问压力的作用。

1. **缓存空结果**：如果查询一个数据时发现数据不存在，可以将这个空结果也缓存起来，设置一个短的过期时间（如几分钟）。这样在这个过期时间内，再次查询同样的数据会直接返回缓存的空结果，避免频繁访问数据库。
2. **使用布隆过滤器**：布隆过滤器是一种概率型数据结构，用于快速判断一个元素是否在一个集合中。**可以在缓存层之前增加布隆过滤器(服务器可能有多个)**，所有查询先经过布隆过滤器，如果判断该数据一定不存在，则直接返回空结果而不访问数据库；如果布隆过滤器判断该数据可能存在，再继续访问缓存或数据库。***缺点：只能增加，不能删除***
3. **参数校验和限流**：对传入的查询参数进行严格校验，过滤掉非法或明显错误的请求，从源头上减少无效查询。此外，可以对频繁访问的请求进行限流，避免短时间内大量请求穿透缓存。





### 缓存击穿（Cache Breakdown）：Redis无，MySQL有，大量***并发连接***请求

1. **热点数据永不过期**：对某些特别重要和访问频率非常高的数据，可以设置为永久缓存，不让其过期。这可以避免缓存击穿的问题，但需要定期手动更新缓存，以确保数据的一致性。
2. **互斥锁（Mutex）**：在缓存失效时，通过加锁机制控制只有一个线程可以查询底层数据库并更新缓存，其余线程等待缓存更新完毕再获取数据。这种方法可以通过分布式锁（如Redis分布式锁）来实现。
3. **双重缓存**：使用双缓存机制，设置两个缓存区域A和B，当A区数据过期时，访问B区的数据，同时异步更新A区的数据。这样即使A区过期，也能从B区获取到稍旧的数据，从而避免了缓存击穿。
4. **请求合并**：在高并发情况下，可以将多个相同的请求合并为一个请求处理，避免多个线程同时去数据库查询相同的数据。这可以通过消息队列或批处理的方式来实现。



### 缓存雪崩（Cache Avalanche）：同一时间大量缓存数据***集中失效***，导致大量请求直接访问数据库

1. **缓存失效时间加随机值**：设置缓存失效时间时，加上一个随机的偏移量，避免大量缓存同时过期。比如，如果默认过期时间是1小时，可以在此基础上加上一个0-10分钟的随机时间。
2. **分布式缓存**：使用分布式缓存系统，如Redis集群，将缓存数据分散在多个节点上。这样，即使某些节点的缓存失效，其他节点的缓存仍然可用，从而分散压力。
3. **缓存预热**：在系统启动或数据更新时，提前将热点数据加载到缓存中，避免在系统运行期间发生缓存雪崩。可以通过定时任务或脚本来实现缓存预热。
4. **异步更新缓存**：当缓存失效时，通过异步方式更新缓存，避免请求线程等待缓存更新完成。在请求到达时，如果发现缓存失效，可以立即返回旧缓存数据，并异步更新缓存。

**缓存击穿** 关注的是缓存数据的热点问题，主要是高并发访问一个失效的缓存。

**缓存穿透** 关注的是缓存和数据库中都不存在的数据频繁查询问题。

**缓存雪崩** 关注的是大量缓存同时失效或缓存服务不可用导致数据库压力骤增的问题。



8、简要介绍一下gRPC？

## 9、gRPC的文件是什么后缀(格式)

`.proto`



## 10、gRPC的代码格式是什么样的？支持定义默认值吗？定义数组的关键字是什么？

接口和消息的定义通常使用 Protocol Buffers (Protobuf) 来进行编写。

### 1. gRPC 的代码格式

gRPC 的服务和消息通常在 `.proto` 文件中定义。以下是一个示例：

```protobuf
syntax = "proto3";

package example;

service MyService {
  // 定义一个 RPC 方法
  rpc MyMethod (MyRequest) returns (MyResponse) {}
}

message MyRequest {
  string name = 1;
  int32 age = 2;
  repeated string hobbies = 3;
}

message MyResponse {
  string message = 1;
}
```

- `syntax = "proto3";`：指定使用 Protobuf 3 的语法。
- `package example;`：定义 Protobuf 的包名。
- `service MyService`：定义一个 gRPC 服务，包含一个或多个 RPC 方法。
- `rpc MyMethod`：定义一个 RPC 方法，接收 `MyRequest` 消息，返回 `MyResponse` 消息。
- `message MyRequest` 和 `message MyResponse`：定义消息类型，类似于结构体或类。

### 2. 默认值

在 Protobuf 3 中，**不支持显式定义默认值**。Protobuf 3 自动为所有基本类型提供默认值：

- `string` 默认是空字符串 `""`。
- `int32`, `int64`, `uint32`, `uint64` 默认是 `0`。
- `bool` 默认是 `false`。
- `enum` 默认是枚举的第一个值。

如果字段未被显式设置，它将使用这些默认值。

例如：

```protobuf
message MyRequest {
  string name = 1;  // 默认值是 ""
  int32 age = 2;    // 默认值是 0
}
```

### 3. 定义数组的关键字

在 Protobuf 中，使用 `repeated` 关键字来定义一个字段为数组（或列表）。例如：

```protobuf
message MyRequest {
  repeated string hobbies = 3;
}
```

在这个示例中，`hobbies` 是一个字符串数组，可以包含零个或多个元素。





11、除了gRPC你还用过哪些RPC技术栈，你所知道的RPC框架有哪些？

12、QUIC相对于HTTP2有哪些重大变化？

13、slice的底层实现？

14、slice和数组的区别？

15、slice的扩容机制？

16、slice是线程安全的吗？

17、map是线程安全的吗？如何实现一个线程安全的map？

18、channel的底层实现原理？

19、channel发送数据和接收数据的过程？

20、defer的作用？

21、defer的底层原理？

22、如果在匿名函数内panic了，在匿名函数外的defer是否会触发panic-recover？反之在匿名函数外触发panic，是否会触发匿名函数内的panic-recover？

23、简单介绍下GMP模型？

24、简单介绍一下Golang的GC



代码手撕 25分钟

- lc206.反转链表 秒了
- lc1143.最长公共子序列 思路对了，中间过程也对 差输出部分没写出来...