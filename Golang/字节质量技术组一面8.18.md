# 字节质量技术组一面 8.18

## 1、如果一段SQL执行缓慢，你该如何排查？

### 1. **查看执行计划（EXPLAIN）**

- 使用 `EXPLAIN` 或 `EXPLAIN ANALYZE` 查看 SQL 的执行计划，分析 SQL 语句的执行步骤，看看是否有表扫描（Full Table Scan）、索引使用不当、或者不合理的连接顺序等问题。例如：

```sql
EXPLAIN SELECT * FROM orders WHERE customer_id = 123;
```

### 2. **检查索引**

- 检查相关表的索引情况，确认查询条件中的列是否有合适的索引。
- 检查索引是否被正确使用，尤其是在 WHERE、JOIN、ORDER BY 和 GROUP BY 子句中。

```sql
SHOW INDEX FROM orders;
```

### 3. **分析表统计信息**

- 确保表的统计信息（Statistics）是最新的。可以通过运行 `ANALYZE TABLE` 或者数据库自动统计功能来更新统计信息。数据库通常根据这些统计信息来决定执行计划。

```sql
ANALYZE TABLE orders;
```

### 4. **优化查询**

- **简化查询**：尝试简化查询，拆分复杂的 SQL，或者分步执行以减少开销。
- **避免子查询**：有时将子查询改写为 JOIN 或者使用临时表会提高性能。
- **减少 SELECT \* 的使用**：仅选择需要的列，而不是使用 `SELECT *`。
- **WHERE 条件优化**：确保 WHERE 子句尽可能早地过滤数据，减少参与后续操作的数据量。

### 5. **检查数据库服务器资源**

- **检查系统资源**：CPU、内存、磁盘 I/O 和网络带宽是否存在瓶颈。

```sql
SHOW FULL PROCESSLIST;
```

- **锁争用**：查看是否有锁争用情况，可能导致 SQL 等待资源。
- **慢查询日志**：检查慢查询日志，分析是否存在其他系统级的瓶颈或数据库配置问题。

```sql
SET GLOBAL slow_query_log = 'ON';
SET GLOBAL long_query_time = 1; -- 记录执行时间超过1秒的查询
SHOW VARIABLES LIKE 'slow_query_log_file'; --查看慢查询日志的位置
```

### 6. **调整数据库配置**

- **缓冲区大小**：调整数据库的缓存和缓冲区大小，如 InnoDB 的 buffer pool size，PostgreSQL 的 shared buffers 等。
- **并发连接数**：检查并发连接数设置是否合理。
- **临时表空间**：增加临时表空间的大小或者将其移动到更快的存储设备。

### 7. **缓存和持久化策略**

- 可以利用缓存机制（如 Redis、Memcached）缓存频繁访问的数据，减少数据库的负担。
- 考虑使用物化视图（Materialized View）来存储复杂查询的结果，减少每次查询的计算量。



## 2、MySql有哪些索引类型？

**1. B-Tree 索引**：

- **描述**：这是 MySQL 中最常见的索引类型。大多数 MySQL 存储引擎（如 InnoDB 和 MyISAM）都支持 B-Tree 索引。
- **应用场景**：适用于全键值、键值范围查找和前缀查找。对于`ORDER BY`、`GROUP BY`和范围查询（如`BETWEEN`、`>`, `<`等）非常高效。
- **前缀索引 (Prefix Index)**：
  - **描述**：可以对字符串列的前几个字符创建索引，而不是整个字符串。减少索引大小，节省空间。
  - **应用场景**：适用于需要索引长字符串但不需要完整索引的场景，例如只需索引前几字符的URL。
- **复合索引 (Composite Index)**：
  - **描述**：复合索引是将多个列组合在一起形成的索引。
  - **应用场景**：当查询条件涉及多个列时，使用复合索引可以提高查询效率。复合索引中的列顺序非常重要，查询必须符合索引的列顺序才能充分利用索引。

**2. Hash 索引**：

- **描述**：使用哈希表实现的索引，只能用于精确查找，不支持范围查找。
- **应用场景**：适用于精确匹配的查询。典型的应用场景是 `MEMORY` 存储引擎的表，或者 InnoDB 引擎的唯一哈希索引（adaptive hash index）。

**3. 全文索引 (Full-Text Index)**：

- **描述**：全文索引用于对文本字段进行全文搜索，在 MySQL 中支持 InnoDB 和 MyISAM 引擎。
- **应用场景**：适用于对大文本字段进行关键词查询，像`MATCH...AGAINST`语句中的全文搜索。

**4. 空间索引 (Spatial Index)**：

- **描述**：空间索引用于处理GIS（地理信息系统）数据的存储和查询，采用 R-Tree 数据结构。
- **应用场景**：适用于 MySQL 中的`Geometry`类型数据，用于处理地理数据的空间查询。





## 3、MySQL有哪几个数据库引擎，它们的主要区别是什么？

### 1. **InnoDB**

- **事务支持**：InnoDB 支持 ACID 事务，因此能够确保数据的可靠性和一致性。支持回滚、提交和崩溃恢复功能。
- **外键支持**：InnoDB 是 MySQL 中唯一支持外键约束的引擎，允许定义外键关系来保证数据完整性。
- **锁机制**：使用行级锁（Row-level locking），因此在高并发环境下表现良好，减少了锁冲突。
- **崩溃恢复**：InnoDB 使用日志文件来记录未完成的事务，以便在数据库崩溃时能够恢复。
- **适用场景**：适用于需要高可靠性、高并发写操作和复杂查询的应用，如金融系统、电商平台等。

### 2. **MyISAM**

- **事务支持**：MyISAM 不支持事务处理，因此不适用于需要数据一致性的关键应用。

- **外键支持**：不支持外键约束，数据完整性需要通过应用程序层来维护。

- **锁机制**：使用表级锁（Table-level locking），在写入操作较多的环境下，可能会导致较高的锁争用。

- **速度**：在读操作频繁、数据不经常更改的场景下，MyISAM 的查询速度比 InnoDB 快。

  - MyISAM 在读操作频繁、数据不经常更改的场景下查询速度比 InnoDB 快的主要原因可以归结为以下几点：

    #### 1. **表级锁（Table-level Locking）**

    MyISAM 使用表级锁定机制，这意味着当进行读或写操作时，整个表会被锁定。这种锁定机制在读操作频繁且数据较少更新的场景下能够非常高效，因为：

    - **锁开销低**：相比 InnoDB 的行级锁，表级锁的开销更低。当只有读操作时，MyISAM 的锁定机制非常简单，因此性能较高。
    - **并发性**：虽然表级锁在写操作频繁时会影响并发性，但在大量读操作的场景下，不存在锁争用的情况，查询性能优异。

    #### 2. **存储结构简单**

    MyISAM 的存储结构相对 InnoDB 更为简单：

    - **数据和索引存储**：MyISAM 将数据和索引分别存储在不同的文件中，这样的结构使得在执行纯粹的读取操作时，可以更快速地访问数据。
    - **不支持事务**：MyISAM 不支持事务处理，这意味着不需要维护事务日志或处理回滚和提交操作，这减少了磁盘 I/O 和 CPU 开销。

    3. **较小的存储开销**

    MyISAM 相比 InnoDB，数据存储效率较高，占用的磁盘空间更小。这种紧凑的存储方式意味着在相同硬件条件下，MyISAM 可以加载更多的数据到内存中，从而提高查询速度。

    #### 4. **全文索引（Full-Text Search）**

    MyISAM 支持内建的全文索引，特别适合文本搜索的场景。在涉及大量文本数据的查询中，MyISAM 的全文索引可以显著提高查询性能，而 InnoDB 直到后来的版本才引入了全文索引功能。

    #### 5. **无外键约束**

    MyISAM 不支持外键约束，减少了维护关系完整性的开销。在没有外键关系或关系维护由应用程序管理的情况下，MyISAM 不需要进行额外的关系完整性检查，因此执行查询的速度更快。

- **适用场景**：适用于读操作较多的应用，如数据仓库、日志记录等。

### 3. **Memory**

- **存储位置**：数据存储在内存中，因此读写速度非常快，但在服务器关闭时数据会丢失。
- **锁机制**：使用表级锁。
- **数据持久性**：不提供数据持久化，适用于需要高速访问临时数据的场景。
- **适用场景**：适用于需要快速访问临时数据的场景，如临时表、缓存等。

### 4. **CSV**

- **存储格式**：数据以 CSV 文件的形式存储在磁盘上，每个表对应一个 CSV 文件。
- **速度**：由于没有索引支持，数据查询速度较慢。
- **兼容性**：适用于需要与外部程序（如 Excel）交换数据的场景。
- **适用场景**：适用于需要简单数据导入/导出功能的应用场景。

### 5. **其他引擎**

- **Aria**：类似 MyISAM，但更为可靠，支持崩溃恢复，通常用于 MariaDB。
- **Federated**：用于访问远程 MySQL 数据库中的表，通过 MySQL 服务器之间的连接，实现跨服务器的分布式数据库。
- **Archive**：用于存储大量的归档数据，主要用于插入和查询操作，不支持索引，适用于存储日志数据。

### 总结

- **InnoDB** 是默认且最常用的引擎，适用于绝大多数应用场景，尤其是那些需要事务支持和数据一致性的场景。
- **MyISAM** 适用于读操作频繁且不要求事务处理的应用。
- **Memory** 适用于需要快速访问的临时数据。
- **CSV** 适用于与外部系统进行数据交换的场景。



4、悲观锁和乐观锁的区别？

5、Redis为什么快？

6、Redis如何保证断电后数据不会丢失？如何做到数据高可用且避免不一致问题？

7、缓存雪崩、击穿、穿透和解决办法？

8、简要介绍一下gRPC？

9、gRPC的文件是什么后缀(格式)

10、gRPC的代码格式是什么样的？支持定义默认值吗？定义数组的关键字是什么？

11、除了gRPC你还用过哪些RPC技术栈，你所知道的RPC框架有哪些？

12、QUIC相对于HTTP2有哪些重大变化？

13、slice的底层实现？

14、slice和数组的区别？

15、slice的扩容机制？

16、slice是线程安全的吗？

17、map是线程安全的吗？如何实现一个线程安全的map？

18、channel的底层实现原理？

19、channel发送数据和接收数据的过程？

20、defer的作用？

21、defer的底层原理？

22、如果在匿名函数内panic了，在匿名函数外的defer是否会触发panic-recover？反之在匿名函数外触发panic，是否会触发匿名函数内的panic-recover？

23、简单介绍下GMP模型？

24、简单介绍一下Golang的GC

25、（给了一段代码，介绍一下是干嘛的）

代码手撕 25分钟

- lc206.反转链表 秒了
- lc1143.最长公共子序列 思路对了，中间过程也对 差输出部分没写出来...