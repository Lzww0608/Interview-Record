## 核心工作思想

+ **资源复用**
+ **任务排队**
+ **统一管理**



## 线程池七大参数

- **corePoolSize (核心线程数):** 线程池中始终保持活动状态的线程数量。
- **maximumPoolSize (最大线程数):** 线程池允许创建的最大线程数量。
- **keepAliveTime (线程空闲存活时间):** 非核心线程空闲的最大存活时间。
- **TimeUnit (时间单位):** keepAliveTime 的时间单位。
- **workQueue (任务队列):** 用于存放等待执行任务的队列，常见的队列类型包括 ArrayBlockingQueue, LinkedBlockingQueue, PriorityBlockingQueue, SynchronousQueue 等。
- **threadFactory (线程工厂):** 用于创建线程的工厂，可以自定义线程的创建方式，例如设置线程名称等。
- **rejectedExecutionHandler (拒绝策略):** 当任务队列已满且线程池线程数达到最大线程数时，新提交的任务会被拒绝执行，拒绝策略定义了如何处理被拒绝的任务，常见的策略包括 AbortPolicy, CallerRunsPolicy, DiscardPolicy, DiscardOldestPolicy 以及自定义策略。





## 线程池创建方式

**1. 基于 Executors 工厂类提供的预定义线程池:**

Java 的 Executors 类提供了一系列静态工厂方法，用于创建常见的线程池类型。这些方法简化了线程池的创建，并提供了针对特定场景的默认配置。

- **Executors.newFixedThreadPool(int nThreads):** **固定大小线程池。**
  - **特点:**
    - 线程池中包含固定数量的线程 (nThreads)。
    - 线程池启动后，立即创建 nThreads 个线程并保持活动状态，除非显式关闭线程池。
    - 使用无界队列 LinkedBlockingQueue 作为任务队列。
  - **适用场景:**
    - **处理 CPU 密集型任务，且任务处理时间相对稳定。**
    - **需要限制并发线程数量，避免资源过度消耗。**
    - **任务队列无界，可能导致内存溢出风险，需注意监控和控制任务提交速度。**
  - **优点:** 响应速度快，因为核心线程数固定，任务提交后可以立即执行。
  - **缺点:** 任务队列无界，可能导致大量任务堆积，最终引发 OOM (OutOfMemoryError)。
- **Executors.newCachedThreadPool():** **可缓存线程池。**
  - **特点:**
    - 线程池大小**不固定，可以动态伸缩**。
    - 核心线程数为 0，最大线程数理论上无限大 (实际上受限于系统资源)。
    - 使用 SynchronousQueue 作为任务队列 (直接提交队列，不存储任务)。
    - 如果有空闲线程 (空闲时间超过 60 秒)，则会被回收。
    - 如果没有空闲线程，且有新任务到来，则会创建新的线程。
  - **适用场景:**
    - **执行大量耗时较短的异步任务。**
    - **任务到达频率较高，但每个任务执行时间短。**
    - **系统资源较为充足，可以容忍线程池动态伸缩。**
  - **优点:** 线程复用率高，可以快速响应新任务，动态伸缩，节省资源。
  - **缺点:** 线程池大小不受限制，可能在极端情况下创建大量线程，导致系统资源耗尽，甚至崩溃。
- **Executors.newSingleThreadExecutor():** **单线程线程池。**
  - **特点:**
    - 线程池中只有一个线程。
    - 使用无界队列 LinkedBlockingQueue 作为任务队列。
    - 所有提交的任务都按照先进先出 (FIFO) 的顺序执行，保证任务的顺序性。
  - **适用场景:**
    - **需要保证任务串行执行的场景，例如按顺序处理任务。**
    - **不需要并发执行任务，但需要线程池的生命周期管理和任务提交的便利性。**
  - **优点:** 保证任务顺序执行，避免线程安全问题，简化多线程编程。
  - **缺点:** 并发能力低，吞吐量有限。
- **Executors.newScheduledThreadPool(int corePoolSize):** **定时任务线程池/可调度线程池。**
  - **特点:**
    - 线程池可以执行定时任务和周期性任务。
    - 核心线程数固定，但最大线程数可以根据需要扩展。
    - 使用 DelayedWorkQueue 作为任务队列 (优先级队列，按照延迟时间排序)。
  - **适用场景:**
    - **需要执行定时任务或周期性任务的场景，例如定时清理缓存、定时发送心跳等。**
    - **可以灵活地调度任务的执行时间。**
  - **优点:** 支持定时任务和周期性任务，功能强大。
  - **缺点:** 调度任务有一定的开销，需要根据实际情况评估性能影响。
- **Executors.newWorkStealingPool(int parallelism) (JDK 8+):** **工作窃取线程池。**
  - **特点:**
    - 基于 ForkJoinPool 实现，适用于并行计算场景。
    - 使用工作窃取算法，提高线程利用率。
    - 线程池大小由 parallelism 参数指定，通常设置为 CPU 核心数。
  - **适用场景:**
    - **CPU 密集型任务，且任务可以分解成子任务并行执行。**
    - **需要最大化利用多核 CPU 的计算能力，提高并行计算效率。**
  - **优点:** 高效的并行计算，提高线程利用率。
  - **缺点:** 适用于特定的并行计算场景，对于 IO 密集型任务或任务依赖性较强的情况可能效果不佳。

**2. 直接使用 ThreadPoolExecutor 自定义线程池:**

Executors 工厂方法提供的线程池虽然方便，但灵活性有限。 如果需要更精细的控制，例如自定义任务队列、拒绝策略、线程工厂等，就需要直接使用 ThreadPoolExecutor 类来创建线程池。

**创建 ThreadPoolExecutor 时，需要配置以下关键参数 (也就是面试常问的线程池参数):**

- **corePoolSize (核心线程数):** 线程池中始终保持活动状态的线程数量。
- **maximumPoolSize (最大线程数):** 线程池允许创建的最大线程数量。
- **keepAliveTime (线程空闲存活时间):** 非核心线程空闲的最大存活时间。
- **TimeUnit (时间单位):** keepAliveTime 的时间单位。
- **workQueue (任务队列):** 用于存放等待执行任务的队列，常见的队列类型包括 ArrayBlockingQueue, LinkedBlockingQueue, PriorityBlockingQueue, SynchronousQueue 等。
- **threadFactory (线程工厂):** 用于创建线程的工厂，可以自定义线程的创建方式，例如设置线程名称等。
- **rejectedExecutionHandler (拒绝策略):** 当任务队列已满且线程池线程数达到最大线程数时，新提交的任务会被拒绝执行，拒绝策略定义了如何处理被拒绝的任务，常见的策略包括 AbortPolicy, CallerRunsPolicy, DiscardPolicy, DiscardOldestPolicy 以及自定义策略。

**自定义策略的选择需要根据具体场景考虑:**

- **任务类型:** CPU 密集型 vs. IO 密集型。
- **并发量:** 预期的高峰并发量和平均并发量。
- **响应时间要求:** 对任务执行延迟的容忍程度。
- **资源限制:** 系统资源 (CPU, 内存) 的限制。
- **任务队列的特性:** 有界队列 vs. 无界队列，公平性，优先级等。
- **拒绝策略的选择:** 保证系统稳定性和可用性，以及对任务丢失的容忍程度。

**3. 基于框架或工具提供的线程池:**

一些框架或工具也提供了线程池的封装或更高层次的抽象，例如：

- **Spring Framework 的 ThreadPoolTaskExecutor:** Spring 提供的线程池封装，可以方便地集成到 Spring 应用中，并利用 Spring 的 IoC 和 AOP 特性进行管理和增强。
- **Guava 的 ListeningExecutorService:** Guava 提供的增强型 ExecutorService，可以方便地处理异步任务的完成回调，并提供 ListenableFuture。
- **Netty 的 EventLoopGroup (本质上也是线程池):** Netty 网络框架用于处理 IO 事件的线程池，针对网络编程进行了优化。



## 线程池拒绝策略

**1. AbortPolicy (默认策略)**

- **行为:** 当新任务被拒绝时，AbortPolicy 会直接抛出一个 **RejectedExecutionException** 异常。
- **特点:**
  - 这是 ThreadPoolExecutor 的 **默认拒绝策略**。
  - 抛出异常能够 **显式地告知** 任务提交者任务被拒绝了，方便进行错误处理或者采取补救措施。
  - 阻止任务提交，保证系统不会因为过载而崩溃。
- **适用场景:**
  - **要求严格的任务执行成功率，不允许任务丢失的情况。**
  - **需要及时发现并处理任务被拒绝的情况。**
  - 适用于对系统资源保护要求较高的场景，当系统过载时，优先保护系统稳定，拒绝部分请求。

**2. CallerRunsPolicy (调用者运行策略)**

- **行为:** 当新任务被拒绝时，CallerRunsPolicy 会 **在提交任务的线程中直接执行被拒绝的任务**。
- **特点:**
  - 不会抛出异常，也不会丢弃任务。
  - **降低了任务提交速度，相当于把一部分任务处理压力转移到任务提交者线程。** 因为提交任务的线程需要花时间去执行被拒绝的任务，而不是继续快速提交新的任务。
  - 可以延缓新任务的提交，给线程池一定的缓冲时间来处理已有的任务。
- **适用场景:**
  - **任务不能丢失，但是允许任务执行有一定的延迟。**
  - **希望通过降低任务提交速度来缓解线程池的压力，避免系统过载。**
  - 适用于对任务执行的可靠性要求较高，但对实时性要求稍低的场景。

**3. DiscardPolicy (丢弃策略)**

- **行为:** 当新任务被拒绝时，DiscardPolicy 会 **默默地丢弃被拒绝的任务，不做任何处理，也不抛出异常**。
- **特点:**
  - **完全忽略被拒绝的任务，不会有任何提示。**
  - 简单粗暴，效率最高，但可能会导致数据丢失。
  - 适用于对系统性能要求极高，可以容忍少量任务丢失的场景。
- **适用场景:**
  - **允许部分任务丢失，对任务的可靠性要求不高。**
  - **高吞吐量、低延迟的场景，例如日志记录、监控数据采集等，允许丢失少量不重要的日志或监控数据。**
  - **不希望因为任务被拒绝而影响主流程的执行。**

**4. DiscardOldestPolicy (丢弃最旧任务策略)**

- **行为:** 当新任务被拒绝时，DiscardOldestPolicy 会 **丢弃任务队列中最旧的任务 (即将要被执行的任务)，然后尝试重新提交当前被拒绝的任务**。
- **特点:**
  - **为新提交的任务腾出空间，尝试执行最新的任务。**
  - 如果队列是有优先级的队列（例如 PriorityBlockingQueue），那么可能会丢弃优先级较低的任务。
  - 可能会导致部分旧的任务永远得不到执行，因为它们可能会被不断地丢弃。
- **适用场景:**
  - **希望优先处理最新的任务，保证新任务能够被执行。**
  - **任务有优先级之分，或者旧任务相对来说不太重要，可以被丢弃。**
  - 适用于缓存更新、实时数据处理等场景，更关注最新的数据和任务。

**5. 自定义拒绝策略**

- **行为:** 你可以 **实现 RejectedExecutionHandler 接口**，并重写 rejectedExecution(Runnable r, ThreadPoolExecutor executor) 方法，来定义自己的拒绝策略。
- **特点:**
  - **高度灵活，可以根据具体的业务需求定制拒绝处理逻辑。**
  - 可以实现更复杂的处理方式，例如：
    - **记录日志:** 记录被拒绝的任务信息，方便后续分析和排查问题。
    - **持久化任务:** 将被拒绝的任务持久化到数据库、消息队列等，稍后重新执行。
    - **告警:** 发送告警通知，提醒管理员系统过载。
    - **限流降级:** 根据被拒绝的任务数量动态调整系统负载，进行限流或降级处理。
- **适用场景:**
  - **需要更复杂的拒绝处理逻辑，默认的策略无法满足需求。**
  - **需要将拒绝事件与其他系统模块联动，例如监控、告警、数据持久化等。**
  - 适用于对系统健壮性、可监控性、可维护性有较高要求的场景。