# 小红书C++一面20250702

面试官问
自我介绍

你简历上的项目比较多样化，为什么会去做这些项目呢

你觉得你以后会想去做什么呢

挑一个你觉得难度最大的项目，然后介绍一下，balabala

项目问题balabala

说一说项目中遇到的一些困难吗

你写这个项目的主要原因是什么

## 你刚才提到了CDN，那么CDN为什么能加速，其原理是什么呢

1. **缩短物理距离，降低网络延迟（Latency）**：
   - **原理**：数据在网络中传输的速度受限于光速，并且每经过一个网络设备（如路由器、交换机）都会产生处理延迟。如果用户和源服务器地理位置相距遥远（例如，上海的用户访问美国的服务器），数据包需要跨越数千公里，经过几十个网络跳数（Hops），累积的延迟会非常高。
   - **CDN解决方案**：CDN在全球各地，特别是主要城市和运营商网络内部署了大量的边缘节点（Edge Node）。当用户请求时，CDN的调度系统会将其引导到物理距离最近、网络质量最好的节点。数据从几十毫秒（ms）的延迟降低到几毫秒，这是最直观的加速体验。
2. **负载均衡与源站减压（Load Balancing & Offloading）**：
   - **原理**：如果所有用户的请求都直接打到源服务器上，服务器的CPU、内存、带宽等资源会迅速成为瓶颈，尤其是在高并发场景下（如双十一、热点新闻）。
   - **CDN解决方案**：绝大部分的用户请求（特别是对于图片、视频、CSS、JS等静态资源）都由CDN的边缘节点直接响应。据统计，一个良好配置的CDN可以为源站卸载超过95%的流量。这极大地减轻了源站的压力，使其能更专注于处理动态业务逻辑（如登录、交易），保障了核心服务的可用性。
3. **网络优化与带宽瓶颈规避**：
   - **原理**：互联网的结构复杂，不同运营商（如电信、联通、移动）之间的互联互通可能存在瓶颈，导致跨网访问速度慢。同时，骨干网的拥塞也时有发生。
   - **CDN解决方案**：CDN节点通常会选择最优的网络路径，甚至与运营商有深度合作，其节点间的传输构成了为内容分发而优化的“高速公路”。当边缘节点需要回源站取数据时（即“回源”），走的也是这条优化过的路径，而不是公网，从而保证了回源的速度和稳定性。
4. **提升安全性**：
   - **原理**：源站IP直接暴露在公网，容易成为DDoS攻击、CC攻击的目标。
   - **CDN解决方案**：CDN作为流量的第一入口，其庞大的分布式节点和带宽资源天然具备了抗DDoS攻击的能力。攻击流量会被分散到各个边缘节点，难以打垮单一的源站。同时，许多CDN服务商还提供WAF（Web Application Firewall）等安全增值服务。



## C++的编译从源码到可执行文件中间的步骤有哪些呢？





## 你了解G++在编译的时候的o(1)、O(2)、O(3)这些优化有什么区别吗

#### -O1 开启的优化（相较于 -O0）

-O1 开启了大约40多个优化选项，核心是消除冗余和简化计算：

- **常量折叠 (Constant Folding)**：在编译期直接计算出常量表达式的值。例如 int x = 2 * 100 * 5; 会被直接编译成 int x = 1000;。
- **公共子表达式消除 (Common Subexpression Elimination)**：如果一个表达式被计算了多次，且其间变量未改变，编译器会只计算一次并复用结果。
- **死代码消除 (Dead Code Elimination)**：删除那些永远不会被执行到的代码。
- **指令重排 (Instruction Scheduling)**：调整指令顺序以更好地利用CPU的流水线，避免停顿。
- **延迟栈指针弹出 (Deferred Pop)**：将多个函数调用的栈清理操作合并，减少指令数。

#### -O2 开启的优化（相较于 -O1）

-O2 是一个重要的分水岭，它开启了几乎所有主流的、被证明是高效的优化：

- **函数内联 (Function Inlining)**：将小函数的调用替换为函数体本身，消除了函数调用的开销（压栈、跳转、返回）。这是最重要的优化之一。
- **寄存器分配优化 (Register Allocation)**：更智能地将变量分配到CPU寄存器中，大大减少对内存的读写，这是性能提升的关键。-O0 下变量基本都在内存（栈）里。
- **循环优化 (Loop Optimizations)**：
  - **循环不变代码外提 (Loop-invariant code motion)**：将循环内部不随迭代变化的计算提到循环外部。
  - **强度削减 (Strength Reduction)**：将计算昂贵的操作替换为等价的廉价操作（如用位移代替乘法 x * 8 -> x << 3）。
- **更强的指令重排和对齐优化**：对代码和数据进行对齐，以匹配CPU的缓存行大小，提高缓存命中率。

#### -O3 开启的优化（相较于 -O2）

-O3 更加激进，追求极致性能：

- **更激进的函数内联**：对于更大的函数也会尝试内联。
- **自动向量化 (Auto-Vectorization)**：利用CPU的SIMD（单指令多数据流）指令集（如SSE, AVX）来并行处理数据。例如，一个对数组每个元素加1的循环，可以被转换成一条指令同时给4个或8个元素加1。这是 -O3 相比 -O2 最大的性能提升来源之一，尤其在科学计算和多媒体处理中。
- **更激进的循环展开 (Loop Unrolling)**：将循环体复制多次，减少循环判断和跳转的开销。这会显著增加代码体积。
- **剖面引导优化 (Profile Guided Optimization, PGO) 的一些预分析**：虽然完整的PGO需要额外步骤，但 -O3 会做一些更复杂的程序流分析。



有什么方法可以操作操作系统的堆的空间呢

malloc、free和new、delete有什么区别吗

malloc的时候操作系统会发生什么事情呢

malloc是怎么做到的呢，简单说一下原理呢

你说一下进程跟线程的异同

## 进程切换的的过程会发生什么事情呢，比如说一个核在一个时间段只能跑一个进程，那么进程在切换的时候会发生什么呢

+ Trap
+ 保存A进程上下文
  + 通用寄存器
  + 程序计数器
  + 栈指针
  + 状态寄存器
  + 进程控制块
+ 调度器
+ 加载B进程上下文
+ 返回内核态



进程间通讯的方法有哪些呢

共享内存是怎么做的呢，可以讲一下他的原理吗



## 除了mutex可以实现进程间同步，还有什么可以实现进程间同步呢

+ 读写锁
+ 条件变量
+ 信号量
+ 管道、消息队列



C++11的标准多了哪些东西呢