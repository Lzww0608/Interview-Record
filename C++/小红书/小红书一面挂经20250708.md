# 小红书一面挂经20250708

没有感谢信，去官网看了下才知道挂了。
算法题都做出来了，八股答得不好（或者说有点惨烈）

vector push_back 的时间复杂度是什么

## 什么是半连接队列，半连接队列满了怎么办？

+ 静默丢弃
+ syn + cookie，不放入半连接队列



Linux 中如何实现一个定时器，能够精确到微秒



## LT、ET 的区别是什么，如何用 LT 处理可写事件。

正确的模式是一个**状态驱动**的动态过程：**按需注册，用完即弃**。

1. **初始状态**：对于一个连接，**只注册 EPOLLIN（读事件）**，不注册 EPOLLOUT。
2. **触发注册**：当你的应用逻辑需要发送数据时，调用 write()。
   - **如果 write() 成功**：太好了，数据发出去了，什么都不用做。
   - **如果 write() 返回 EAGAIN**：这才是关键！说明发送缓冲区满了。此时，你需要：
     a. 将**未发送成功的数据**保存到一个应用层的**发送缓冲区**（比如一个 std::string 或 std::vector<char>，与该连接关联）。
     b. 调用 epoll_ctl **修改**该 fd 的监听事件，**加上 EPOLLOUT**。
3. **处理事件**：当 epoll_wait 返回，并且事件中包含 EPOLLOUT 时：
   a. 这表示内核的发送缓冲区有空间了。
   b. 你从应用层的发送缓冲区中取出之前未发送的数据，再次调用 write() 尝试发送。
   c. 继续 write() 直到所有应用层缓冲区的数据都发送完毕，或者 write() 再次返回 EAGAIN。
4. **触发注销**：
   - **如果应用层发送缓冲区的数据已全部发送完毕**：你**必须**再次调用 epoll_ctl **修改**该 fd 的监听事件，**移除 EPOLLOUT**，只留下 EPOLLIN。这是防止 CPU 100% 的关键一步。
   - **如果 write() 再次返回 EAGAIN**：说明内核缓冲区又满了，你什么都不用做，保持 EPOLLOUT 的监听状态，等待下一次可写通知。



## 给你一个二叉树，如何保存到磁盘，方便下次读取。(如何序列化二叉树)





## 写一个 web 服务，如何减少中间层读写消耗的内存资源



手撕：

## 使用 stdlib.h 中的 rand() 函数，估算 π\piπ 的值



## 1 – n 按照字典序排序，不能暴力





两个线程交替打印