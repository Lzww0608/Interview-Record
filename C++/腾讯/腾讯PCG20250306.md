# 腾讯PCG20250306

#### 一面 1h

1.自我介绍

2.做题，因为是感觉是原创题，所以具体的内容就不说了，大概就是矩阵下棋，判断是否冲突，不冲突

的话最多可以摆多少棋子

## 3.浏览器输入url后会发生什么

1. 解析
2. DNS查询到IP
3. 建立TCP
4. 发送HTTP请求
5. 服务器处理请求并返回
6. 浏览器接收并渲染网页



## 4.不同DB库的表如何联表查询，怎样优化

1. MySQL之间可以用federated table
2. 数据复制与同步
3. 应用层程序



## 5.数据库分页了解吗

数据库中检索大量数据时，将数据分割成多个独立的“页面”进行展示和处理的一种技术。  它允许应用程序每次只从数据库获取和处理少量数据（一个页面），而不是一次性加载所有结果。**页是数据库进行磁盘 I/O 操作的最小单位。**

1. 性能优化
2. 提升用户体验，按页加载
3. 资源管理：拒绝服务

`LIMIT` `OFFSET`

- 表的数据确实分散在多个数据页中。
- B+ 树索引是一个独立的索引结构，它由索引页构成，并且叶子节点指向存储实际数据行的数据页。
- **不是每个数据页都有一颗 B+ 树。** B+ 树索引是表级别的索引，它指向分散在各个数据页中的数据行。



## 6.http2.0了解吗

HTTP/2.0 的目标是 **提升 Web 性能，降低延迟，并优化网络资源利用率**。  它并没有废弃 HTTP/1.1 的语义 (如方法、状态码、URI、头部字段等)，而是 **在传输层做了彻底的改造**。

**1. 二进制分帧层 (Binary Framing Layer):  核心变革**

- **HTTP/1.1:** 基于 **文本协议**。 请求和响应都以纯文本形式传输，头部和消息体之间用空行分隔。  虽然易于人类阅读和调试，但解析效率低，容易出错。
- **HTTP/2.0:** 引入了 **二进制分帧层**。  所有的通信数据被分割成更小的 **帧 (Frames)**，并以二进制格式编码传输。

**2. 多路复用 (Multiplexing):  革命性的性能提升**

- **HTTP/1.1:**  默认情况下，每个 TCP 连接只能处理一个请求/响应 exchange (虽然有 Keep-Alive 和 Pipelining，但仍存在限制和问题，如 Head-of-Line Blocking)。  对于需要加载多个资源的网页 (例如图片、CSS、JS)，浏览器通常需要建立多个 TCP 连接 (通常限制在 6-8 个)，造成连接建立和维护的开销。
- **HTTP/2.0:**  引入了 **多路复用**。  **在一个 TCP 连接上，可以并行地发送多个请求和响应，而不需要按顺序等待。**  这是通过 **流 (Streams)** 的概念实现的。
  - **Stream (流):** 每个请求/响应 exchange 都被分配一个唯一的流 ID，并被分割成帧在 TCP 连接上传输。 来自不同流的帧可以交错发送，接收端根据流 ID 将帧重新组装成完整的请求和响应。

**3. 头部压缩 (Header Compression) - HPACK:**

- **HTTP/1.1:**  HTTP 头部信息通常是文本格式，并且在每个请求和响应中都会重复发送，即使很多头部字段在同一个连接的后续请求中是相同的。 这会浪费带宽，尤其是在移动网络等带宽受限的环境下。
- **HTTP/2.0:**  使用了 **HPACK 头部压缩算法**。  HPACK 利用了头部字段的冗余性，使用以下策略进行压缩：
  - **静态字典:** 预定义了一组常用的头部字段及其索引，可以直接使用索引代替完整的头部字段名和值。
  - **动态字典:** 在连接的生命周期内，维护一个动态更新的字典，记录最近发送过的头部字段。 后续请求中如果出现相同的头部字段，可以使用字典中的索引代替。
  - **哈夫曼编码:** 对头部字段进行哈夫曼编码，进一步减小数据大小。

**4. 服务器推送 (Server Push):  主动推送资源**





## 7.索引了解多少，说一下

| 索引类型        | 数据结构            | 适用查询类型                          | 优点                                           | 缺点                                        | 适用场景                                                 |
| --------------- | ------------------- | ------------------------------------- | ---------------------------------------------- | ------------------------------------------- | -------------------------------------------------------- |
| **B-Tree 索引** | B-Tree (B+Tree)     | 等值、范围、排序、前缀匹配            | 通用性强、查询效率高、支持排序                 | 插入/删除开销、存储空间开销                 | 广泛应用，通用索引                                       |
| **Hash 索引**   | Hash 表             | 等值查询                              | 等值查询速度极快                               | 仅适用于等值查询、不支持范围/排序、哈希冲突 | 等值查询性能要求极高，不需范围/排序                      |
| **全文索引**    | 倒排索引            | 文本关键词搜索                        | 高效文本搜索、支持复杂搜索条件                 | 维护/存储开销大、不适用于非文本数据         | 文本内容搜索应用，如搜索引擎、文章搜索、商品描述搜索     |
| **空间索引**    | R-Tree, Quad-Tree等 | 空间查询 (距离、范围、相交等)         | 高效空间查询、支持多种空间数据类型             | 实现复杂、维护/存储开销大                   | GIS、LBS、地图应用、城市规划、导航系统                   |
| **位图索引**    | 位图                | 低基数列等值查询、AND/OR 运算         | 低基数列查询高效、AND/OR运算效率高、压缩效率高 | 不适合高基数列、更新开销大                  | 数据仓库、BI、低基数列分析查询、静态数据                 |
| **聚集索引**    | B-Tree (通常)       | 全表扫描、范围查询、排序 (基于索引列) | 查询速度快 (索引列)、范围/排序性能好           | 插入/更新开销大、只能有一个聚集索引         | 经常范围查询、排序，查询列与索引列一致，通常用于主键索引 |
| **非聚集索引**  | B-Tree (通常)       | 多种查询 (基于索引列)                 | 可以创建多个索引、维护开销相对较小             | 可能需要回表查询                            | 多列查询、查询列与聚集索引列不一致，加速非聚集索引列查询 |
| **组合索引**    | B-Tree (通常)       | 多条件查询 (前导列)                   | 提高多条件查询效率、可用于覆盖索引             | 维护开销增加、最左前缀原则                  | 经常多条件查询，前导列经常被用作查询条件                 |
| **唯一索引**    | B-Tree, Hash等      | 等值查询 (唯一列)                     | 保证数据唯一性、查询效率高                     | 维护唯一性约束开销、插入性能略受影响        | 需要保证数据唯一性的列，同时加速查询                     |

在 InnoDB 存储引擎中，索引主要分为两种类型：

1. **聚集索引 (Clustered Index)**
2. **二级索引 (Secondary Index) / 非聚集索引 (Non-Clustered Index)**

**1. 聚集索引 (Clustered Index) -  通常不需要回表，但也有例外情况**

- **InnoDB 的特性:** 在 InnoDB 中，**表数据本身就是按照聚集索引的键值排序存储的**。 聚集索引决定了数据行的物理存储顺序。
- **主键索引 (PRIMARY KEY):** 如果你在表上定义了主键 (PRIMARY KEY)，InnoDB 会默认将主键作为聚集索引。 如果没有显式定义主键，InnoDB 会尝试使用第一个 `UNIQUE NOT NULL` 索引作为聚集索引。 如果都没有，InnoDB 会隐式地创建一个 row ID 作为聚集索引。
- **叶子节点存储数据行:** 聚集索引的叶子节点直接存储了 **完整的数据行 (所有列的数据)**。



8.你能接受什么程度的加班（害怕）

9.反问

#### 二面 40 min

7、8、9全都不了解

1.自我介绍



## 2.TCP了解吗，说一下具体的一些机制

1. 可靠传输
2. 流量控制
3. 拥塞控制



## 3.https

| 特性           | HTTP                                     | HTTPS                                        | 改进                                                         |
| -------------- | ---------------------------------------- | -------------------------------------------- | ------------------------------------------------------------ |
| **安全性**     | **不安全**，数据明文传输，易被窃听和篡改 | **安全**，数据加密传输，身份验证，数据完整性 | **核心改进**：提供数据保密性、身份验证和数据完整性，显著提升安全性，防止窃听、篡改和中间人攻击 |
| **加密**       | 不加密                                   | 使用 SSL/TLS 协议加密                        | 数据加密，保护数据传输过程中的隐私                           |
| **身份验证**   | 无                                       | 通过数字证书验证服务器身份                   | 验证服务器身份，防止连接到伪造网站                           |
| **数据完整性** | 无                                       | 使用消息摘要算法保证数据完整性               | 确保数据在传输过程中没有被篡改                               |
| **端口**       | 默认 80 端口                             | 默认 443 端口                                |                                                              |
| **性能**       | 性能较高，开销较小                       | 性能略有下降，增加 SSL/TLS 加密解密开销      | 加密解密过程会带来一定的性能开销，但现代计算机性能提升，影响逐渐减小，且安全收益远大于性能损失 |
| **SEO/信任**   | 无明显优势                               | SEO 有优势，提升用户信任度                   | 有助于 SEO 排名，提升用户对网站的信任感                      |



4.什么是多态

5.深拷贝和浅拷贝

6.malloc和new

7.RPC了解吗

8.微服务了解吗

9.docker了解吗

#### 三面 1h

1.自我介绍

## 2.乐观锁、悲观锁了解吗

- **悲观锁 (Pessimistic Locking):** 认为数据在并发环境下**一定会发生冲突**，因此在数据访问前就先加锁，独占资源，确保在整个事务过程中数据不会被其他事务修改。就像它的名字一样，态度比较“悲观”。
- **乐观锁 (Optimistic Locking):** 认为数据在并发环境下**一般不会发生冲突**，因此不会在数据访问前加锁，而是在数据提交更新时才去检查数据是否被修改过。如果发现数据被修改了，则更新失败，需要进行相应的处理（例如重试）。 态度比较“乐观”。



3.布隆过滤器了解吗

4.索引了解多少，B+树的优势

5.写题

a.给定一个无序数组arr，找到数组中未出现的最小正整数，例如arr = [-1, 2, 3, 4]。返回1，arr = [1, 2, 3, 4]，返回5。

b.整数字符串相加 -> 两个字符串都有小数点 -> 有可能没有小数点

6.反问