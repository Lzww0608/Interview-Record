# vivoC++一面

更新一下，已完成hr面，薪酬预期25w，一周内给结果，许愿offer~~~~

本来想二面结束一起发的，但是想到早点发出来可能会对明天面试的小伙伴有帮助，就先发出来吧，顺便为明天的hr面攒点人品。
不多说，直接上面经。
1）怎么设计一个tcp模型
我答的类似于Reactor

2）用多线程还是单线程
我说一个线程负责监听文件描述符，一个线程池负责处理相应文件描述符

3）怎么监听
epoll

4）select poll epoll区别

5）LT和ET模式区别

## 6）阻塞和非阻塞文件描述符都可以用LT和ET吗





7）线程池用什么模型（忘了怎么问的了）

我说生产者消费者队列，解释了一下



8）操作这个队列需要加锁吗？加什么锁？
互斥锁，解释了一下。
9）线程池怎么设计
接着上面的生产者消费者队列的思路说了下应该包括哪些函数。

## 10）listen调用返回-1的原因可能有哪些？
**文件描述符自身的问题（通常是代码Bug）**

- **EBADF (Bad file descriptor)**：传入的`sockfd`参数不是一个有效的、打开的文件描述符。这通常意味着这个`sockfd`可能在调用`listen`之前就被意外地`close()`了，或者`socket()`函数从一开始就失败了，返回了一个无效值。
- **ENOTSOCK (Socket operation on non-socket)**：传入的`sockfd`虽然是一个有效的文件描述符，但它指向的不是一个socket，而可能是一个普通文件或管道。

**Socket状态或协议的问题（逻辑或配置错误）**

- **EOPNOTSUPP (Operation not supported)**：这是个很关键的错误，它意味着我们试图在一个不支持连接监听的socket类型上调用`listen`。最典型的例子就是我们创建了一个UDP（`SOCK_DGRAM`）套接字，却尝试对它进行`listen`。`listen`是专为TCP（`SOCK_STREAM`）这类面向连接的协议设计的。
- **EINVAL (Invalid argument)**：这个错误在某些实现中可能表示这个socket已经处于监听状态了，重复调用`listen`就会导致此错误。

**地址和端口的冲突问题（最常见的运行时问题）**

- `EADDRINUSE` (Address already in use)：这是我在实际开发中遇到最频繁的错误。它意味着我们尝试bind

  和listen的IP地址和端口对，已经被系统中的另一个socket占用了。常见的原因有两个： 

  - 我们的服务已经有一个实例在运行了。
  - 我们的服务刚刚异常退出或重启，之前占用的端口还处于TCP的`TIME_WAIT`状态，内核认为它还在被使用。对于这种情况，我们可以在`bind`之前通过`setsockopt`设置`SO_REUSEADDR`选项，来允许程序立即重用这个地址和端口，这是解决服务快速重启问题的标准做法。

**权限和系统资源问题（环境和运维问题）**

- **EACCES (Permission denied)**：权限不足。一个非常典型的场景是，我们的服务尝试监听一个1024以下的端口（如80端口），但是我们是以一个普通用户身份运行的程序。在类Unix系统中，监听这些特权端口需要root权限。
- **ENOBUFS 或 ENOMEM (No buffer space/memory available)**：系统资源耗尽。这意味着内核没有足够的内存来为这个监听socket创建所需要的连接队列（包括半连接队列和全连接队列）。这种情况在现代服务器上比较罕见，但如果发生，则表明系统处于极度高负荷或内存泄漏的状态。



11）一个大文件怎么统计单词频率？
先拆分单词，在使用hash map统计
12）追问，如果一个hash_map存不下呢？
对哈希值求余映射到多机（分组），分别进行统计
13）C++内存泄漏处理方法
先查看代码是否有未初始化的指针或者释放后没设置成null的指针，
或者使用相关库函数清理。
14）追问有哪些库函数
不知道
15）知道单例模式吗？手写单例模式。
写了双检查锁的，本来打算写完等面试官问双检查锁存在什么问题，结果写一半面试官说知道你想怎么写了，时间差不多了就先这样吧。
16）反问
略
差不多就是这样，去撸线程池了。