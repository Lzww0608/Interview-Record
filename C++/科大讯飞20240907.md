# 科大讯飞20240907

## 看到项目里有web服务器，有协程，问了进程线程协程的区别。

| 特性         | 协程（Coroutine）              | 线程（Thread）                        | 进程（Process）                                        |
| ------------ | ------------------------------ | ------------------------------------- | ------------------------------------------------------ |
| 创建开销     | 较低                           | 较高                                  | 较高                                                   |
| 切换开销     | 较低（用户态切换）             | 较高（内核态切换）                    | 更高（内核态切换）                                     |
| 内存占用     | 较小（根据实现，通常为 KB 级） | 较大（初始栈大小约 1MB）              | 最大（需要分配独立内存空间）                           |
| 调度         | 由程序代码显式控制             | 由操作系统内核调度                    | 由操作系统内核调度                                     |
| 通信方式     | 直接调用或通过共享状态         | 需要显式使用锁机制，避免竞争条件      | 进程间通信需要使用 IPC（如管道、消息队列、共享内存等） |
| 并发模型     | 通常为协作式（手动切换）       | 1:1（一个线程映射到一个操作系统线程） | N:1（进程独立运行，各自拥有完整资源）                  |
| 隔离性       | 共享内存                       | 共享内存                              | 完全隔离，进程间互不影响                               |
| 崩溃影响范围 | 可能影响同协程内的其他协程     | 可能影响同进程内的其他线程            | 不影响其他进程                                         |



## Python的协程了解吗？asyncio



## 宏和模板的区别

### 1. 宏定义 (Macro)

宏定义是通过预处理器指令 `#define` 实现的。它们在编译前的**预处理阶段**展开，进行简单的文本替换。

**特点：**

- **文本替换**：宏定义仅仅是文本替换，不进行类型检查。例如：

  ```c
  #define SQUARE(x) (x * x)
  ```

  当调用 `SQUARE(5)` 时，编译器会把它替换为 `(5 * 5)`。

- **没有类型检查**：宏没有类型检查的概念，这意味着在使用过程中容易出现意想不到的错误。例如：`SQUARE(1+2)` 会被展开为 `(1+2 * 1+2)`，即 `1 + (2 * 1) + 2`。

- **调试困难**：由于宏是**预处理阶段**处理的，调试时不能像正常代码那样逐步调试宏的展开过程。

- **没有作用域**：宏没有作用域的概念，宏定义会一直有效直到被 `#undef` 取消定义。

- **代码膨胀**：宏展开会导致代码膨胀，如果宏被大量使用，生成的目标代码可能会很大。

### 2. 模板 (Template)

模板是 C++ 的一个特性，它允许定义通用的函数或类，使得这些函数或类可以操作多种类型的数据。模板在**编译阶段**进行类型检查和实例化。

**特点：**

- **类型安全**：模板是类型安全的，编译器会在编译时检查类型是否匹配。例如：

  ```c
  template <typename T>
  T square(T x) {
      return x * x;
  }
  ```

  如果调用 `square(5)`，编译器会生成一个处理 `int` 类型的函数；如果调用 `square(5.0)`，则会生成一个处理 `double` 类型的函数。

- **调试友好**：模板是编译器支持的特性，调试时可以看到模板的实例化过程。

- **作用域明确**：模板具有作用域，模板定义在某个作用域中并且不会自动扩展到其它作用域。

- **不导致代码膨胀**：尽管模板实例化会生成多个版本的代码，但它们仅针对不同的类型生成，不会像宏那样盲目地进行文本替换。

- **泛型编程**：模板支持泛型编程，可以创建与类型无关的通用代码。

### 总结

- **宏定义** 是简单的文本替换，不进行类型检查，容易出错且调试困难。
- **模板** 是类型安全的编译器特性，支持泛型编程，能生成类型安全的代码，并且在编译时进行类型检查和实例化。



## 如何将一个宏函数改写成模板函数？

假设我们有一个简单的宏函数，用于计算平方值：

#### 原始宏函数

```cpp
#define SQUARE(x) ((x) * (x))
```

这个宏函数的问题是：

- **没有类型检查**：`SQUARE(1+2)` 会被错误地展开为 `((1+2) * (1+2))`。
- **可能导致副作用**：如 `SQUARE(++x)` 会导致 `x` 被递增两次。

#### 改写为模板函数

使用模板函数替代这个宏定义：

```cpp
#include <iostream>

// 定义模板函数
template <typename T>
T square(T x) {
    return x * x;
}

int main() {
    // 使用模板函数
    std::cout << square(5) << std::endl;     // 输出 25
    std::cout << square(5.5) << std::endl;   // 输出 30.25
    std::cout << square(1 + 2) << std::endl; // 输出 9
    return 0;
}
```

#### 模板函数的优势

- **类型安全**：编译器会根据传入的参数类型生成相应的函数。
- **无副作用**：表达式只会被计算一次，例如 `square(++x)` 只会递增一次。
- **易于调试**：模板函数是标准的函数调用，支持断点和调试。

### 处理更加复杂的宏

如果宏函数包含更多逻辑，例如条件判断，可以同样使用模板函数，结合 `if`、`switch` 或其他 C++ 语言特性实现。例如：

#### 复杂宏函数示例

```cpp
#define MAX(a, b) ((a) > (b) ? (a) : (b))
```

#### 改写为模板函数

```cpp
#include <iostream>

// 定义模板函数
template <typename T>
T max(T a, T b) {
    return (a > b) ? a : b;
}

int main() {
    // 使用模板函数
    std::cout << max(5, 10) << std::endl;    // 输出 10
    std::cout << max(3.14, 2.71) << std::endl; // 输出 3.14
    std::cout << max('a', 'b') << std::endl; // 输出 b
    return 0;
}
```





## 构造函数可以为虚吗

**对象的构造顺序**：当一个对象被构造时，构造函数从基类开始，一层一层向下调用派生类的构造函数。在这个过程中，虚表尚未完成设置。因此，构造函数不能是虚的。

**虚函数机制依赖对象的完整性**：虚函数的调用依赖于虚表，而虚表是在对象完全构造后才初始化好的。如果构造函数是虚的，那么在构造阶段调用虚函数将无法正确找到函数地址。

**对象未完全构造**：在调用派生类构造函数之前，基类部分还未被初始化完全，虚函数调用可能导致未定义行为。



## C++20其他特性？答了concept和require

### 1. Modules（模块）

模块是C++20引入的一种新特性，用于替代传统的头文件机制，旨在改善代码的模块化和编译时间。

#### 主要特性

- **模块化**：将代码分割成独立的模块，可以显著减少编译时间和依赖管理的复杂性。
- **更快的编译速度**：通过模块化，可以减少重复编译，提高编译速度。
- **避免宏污染**：模块可以避免宏带来的命名冲突问题。
- **明确的接口**：模块显式地定义了导出和导入的接口，提高了代码的可读性和安全性。

#### 示例代码

```cpp
// my_module.cpp
export module my_module;  // 定义并导出模块
export void greet() {
    std::cout << "Hello from module!\n";
}

// main.cpp
import my_module;  // 导入模块

int main() {
    greet();
}
```

### 2. Coroutines（协程）

协程是一种用于简化异步编程的新特性，使得可以通过更直观的方式来编写异步代码。

#### 主要特性

- **异步操作**：协程允许函数在需要等待某些操作完成时挂起并返回调用者，然后在条件满足时恢复执行，即实现一个hook完成yield和resume。
- **状态保持**：协程可以在挂起时保持其状态，当恢复执行时可以从中断的地方继续。
- **高效的资源管理**：协程相比于传统的线程更轻量级，具有更低的上下文切换开销。

#### 示例代码

```cpp
#include <iostream>
#include <coroutine>

struct Generator {
    struct promise_type;
    using handle_type = std::coroutine_handle<promise_type>;

    struct promise_type {
        int value;
        auto get_return_object() { return Generator{handle_type::from_promise(*this)}; }
        auto initial_suspend() { return std::suspend_always{}; }
        auto final_suspend() noexcept { return std::suspend_always{}; }
        void return_void() {}
        void unhandled_exception() { std::exit(1); }
        auto yield_value(int val) {
            value = val;
            return std::suspend_always{};
        }
    };

    handle_type h;
    Generator(handle_type h) : h(h) {}
    ~Generator() { h.destroy(); }
    bool next() { return h.resume(), !h.done(); }
    int value() const { return h.promise().value; }
};

Generator sequence() {
    for (int i = 0; i < 3; ++i)
        co_yield i;
}

int main() {
    auto gen = sequence();
    while (gen.next()) {
        std::cout << gen.value() << "\n";
    }
}
```

### 3. Ranges（范围库）

范围库提供了一组更强大和灵活的方式来操作集合，使得代码更简洁和易读。

#### 主要特性

- **视图和适配器**：范围库通过视图和适配器提供了对集合的惰性求值操作，使得可以在不复制数据的情况下进行链式操作。
- **更好的与算法结合**：范围库与标准库算法结合得更加紧密，使得代码更具表达力和简洁性。
- **Pipeline风格**：支持通过管道操作符进行链式调用，极大地简化了代码。

#### 示例代码

```cpp
#include <iostream>
#include <vector>
#include <ranges>
#include <algorithm>

int main() {
	std::vector<int> v = { 5, 2, 1, 3, 0, 4, 6 };

	// 过滤和变换范围
	auto result = v | std::views::filter([](int n) { return n % 2 == 0; })
		| std::views::transform([](int n) { return n * n; });

	for (int n : result) {
		std::cout << n << " ";
	}
    std::cout << "\n";
    
	std::ranges::sort(v);
	for (int x : v) {
		std::cout << x << " ";
	}
}
```

### 4. Concepts（概念）

概念用于为模板定义约束条件，提高模板的可读性和错误信息的清晰度。

#### 主要特性

- **约束模板参数**：通过概念可以为模板参数定义约束条件，从而限制模板实例化时的类型。
- **提高可读性**：概念使得模板代码更具可读性，因为可以明确指出模板参数的预期行为和性质。
- **更好的错误信息**：在不满足概念约束时，编译器可以提供更清晰的错误信息，便于调试。

#### 示例代码

```cpp
c#include <concepts>
#include <iostream>

// 定义一个概念，约束类型必须支持加法操作
template<typename T>
concept Addable = requires(T a, T b) {
    { a + b } -> std::convertible_to<T>;
};

template<Addable T>
T add(T a, T b) {
    return a + b;
}

int main() {
    std::cout << add(1, 2) << std::endl;  // 合法
    // std::cout << add("Hello, ", "world!");  // 非法，不满足Addable概念
}
```



## web服务器惊群问题？这个答得不好

**惊群问题**（Thundering Herd Problem）是指在多进程或多线程的服务器架构中，当一个事件（如一个网络连接请求或信号）到来时，会唤醒多个进程或线程，但最终只有一个进程或线程能处理该事件，其他的进程或线程被唤醒后发现没有任务可做，又重新进入睡眠状态。这个问题会导致系统资源浪费，降低性能，增加上下文切换的开销，从而影响服务器的吞吐量和响应时间。

### 发生原因

惊群问题主要发生在使用多进程或多线程模型的服务器上，特别是在使用一些系统调用时，如：

- `accept()`：多个进程或线程在等待一个新的连接，当有新的连接到来时，所有进程或线程会被唤醒，但只有一个能成功接受连接。
- `select()` 或 `poll()`：在多进程或多线程的模型下监听同一个套接字（Socket）时，会出现多个进程或线程同时被唤醒的情况。

### 解决方法

1. **使用epoll或kqueue**：
   - 在Linux系统上，`epoll`是改进版的`select/poll`，它避免了惊群问题。`epoll`的事件通知机制可以确保只有一个线程被唤醒。
   - 类似地，在BSD系统上，`kqueue`提供了类似的功能。
2. **采用同步锁机制**：
   - 使用互斥锁（Mutex）、信号量（Semaphore）等机制来保护关键区域，确保只有一个线程能处理到达的事件。
3. **进程池或线程池**：
   - 使用进程池或线程池，在池中控制线程或进程的数量，避免同时唤醒大量进程或线程。
4. **使用异步I/O**：
   - 异步I/O（Asynchronous I/O）可以避免大量进程或线程的同步等待，减少惊群问题。
5. **Accept Mutex**（仅对Web服务器有效）：
   - 某些Web服务器（如Nginx）实现了`Accept Mutex`机制，通过互斥锁来控制多个进程的`accept`操作，避免同时竞争监听套接字。
6. **内核参数优化**：
   - 调整内核参数，如TCP的接受队列长度等，可以在一定程度上缓解惊群问题。



## epoll水平和边缘

### 水平触发（Level Triggered, LT）

**特点**：

1. **默认模式**：`epoll` 的默认触发模式是水平触发。
2. **重复通知**：如果一个文件描述符上的事件（如数据可读或可写）仍然存在，只要没有被处理完，`epoll_wait` 会反复返回该事件。这意味着如果你没有读取所有数据，下一次`epoll_wait`调用时，依旧会通知这个文件描述符。
3. **简单易用**：这种模式更容易编写和调试，因为只要事件存在，就会持续触发。

**适用场景**：

- 适用于大多数应用场景，因为它的使用逻辑简单。
- 对于新手或简单的 I/O 处理来说，LT 更容易实现和维护。

**示例**： 如果一个套接字有未读的数据，每次调用 `epoll_wait`，该套接字的事件都会被通知，直到所有数据被读取。

### 边缘触发（Edge Triggered, ET）

**特点**：

1. **高效模式**：边缘触发模式在性能上优于水平触发，因为它减少了事件通知的次数。
2. **只通知一次**：当一个事件从未发生到发生的状态改变时，ET 仅通知一次。之后即使事件条件仍然满足（如套接字上仍有数据未读），也不会再触发通知，除非事件状态再次改变。
3. **需要非阻塞 I/O**：通常需要将文件描述符设置为非阻塞模式，因为在读/写操作未完成时，ET 不会再次提醒，因此如果操作阻塞会导致程序挂起。

**适用场景**：

- 适用于需要高性能的应用程序，比如高并发网络服务器。
- 适合对性能要求较高的场景，但对程序的实现要求更复杂，需要确保在通知后尽可能快地处理事件。

**示例**： 如果一个套接字上有新数据到来，`epoll_wait` 会通知一次，然后程序必须在这次通知后尽可能多地读取数据，直到没有数据为止。否则，后续不会再收到这个套接字的通知。

### 总结对比

- **LT 模式**：更易于使用，因为它会不断通知你去处理存在的事件，适合大多数简单场景。
- **ET 模式**：更高效，因为它减少了事件通知次数，但使用起来更复杂，需要使用非阻塞 I/O，并确保在收到事件通知时彻底处理事件，避免遗漏。



- 虚拟内存



## 如何定位内存泄漏？

BPF, eBPF



- 内存对齐
- 线程池



## Go协程与cpp、py的不同？有栈无栈、调度器

### 1. Goroutine (Go语言)

- **轻量级线程**: Goroutines是Go语言中的并发单元，比操作系统线程更加轻量级。每个Goroutine在启动时只有几KB的栈空间，并且可以根据需要动态增长。
- **调度**: Goroutine由Go的运行时管理和调度，不依赖操作系统线程。Go runtime负责多路复用多个Goroutine到一个或多个操作系统线程中，这种调度机制被称为GMP调度模型。
- **同步**: Goroutine通过通道（channel）来进行通信和同步，避免了使用显式锁的复杂性。
- **阻塞操作**: Goroutine中的阻塞操作（如I/O）不会阻塞其他Goroutine，因为它们是由Go runtime来管理的。

### 2. C++ 协程

- **基于标准库的特性**: C++协程是C++20标准引入的特性，使用`co_await`、`co_yield`和`co_return`等关键字。
- **实现细节**: C++协程是编译器级别的特性，由编译器将协程编译为状态机。每个协程由一套内部的状态机管理，其生命周期和状态转换由编译器自动生成的代码控制。
- **控制**: C++协程提供了对协程生命周期和状态转换的精细控制，这允许高性能的并发模型实现，但也要求程序员对其行为有深入理解。
- **同步**: C++协程通常与`future`、`promise`或自定义的等待器一起使用，进行异步任务的调度和结果的传递。

### 3. Python 协程

- **语言层支持**: Python的协程是基于生成器的并发特性，通过`async def`定义协程，使用`await`等待异步操作完成。
- **事件驱动模型**: Python协程通常与事件循环（如`asyncio`）一起使用，所有的异步任务在同一个线程内被调度。
- **轻量级**: Python的协程非常轻量，因为它们本质上是生成器函数，使用较少的内存和资源。
- **阻塞与非阻塞**: Python协程使用`await`关键字来挂起执行，非阻塞地等待I/O或其他异步操作完成。Python的协程通过`asyncio`来管理并发任务。

### 总结

- **性能**: Goroutine和C++协程通常比Python协程性能更好，特别是在I/O密集和高并发场景下。Go语言对Goroutine的调度和资源管理非常高效，C++协程允许高度优化的并发实现。
- **复杂性**: C++协程提供了最高的控制粒度，但也带来了更高的复杂性。Goroutines相对简单易用，Python协程最容易上手但性能不及前两者。
- **应用场景**: Goroutines适合需要高并发和高性能的服务端应用程序；C++协程适合对性能要求极高且需要精细控制的场合，如游戏开发或系统编程；Python协程更适合轻量级的异步I/O操作，如Web服务器或网络爬虫。





## map和unordered_map的实现

### 1. `std::map`

#### 实现方式：

- `std::map`通常使用 **红黑树**（或其他平衡二叉搜索树，如AVL树）来实现。
- 红黑树是一种自平衡的二叉搜索树，它确保在插入和删除操作后，树的高度始终保持平衡，从而使得查找、插入和删除操作的时间复杂度为 **O(log n)**。

#### 特性：

- **有序性**：`std::map`中的元素是按照键的顺序自动排序的。迭代器遍历`map`时会按照键的升序进行。
- **时间复杂度**：查找、插入和删除操作的平均时间复杂度为 **O(log n)**。
- **内存使用**：由于红黑树的指针结构，相比`unordered_map`，`map`的内存使用可能会更高。
- **迭代稳定性**：红黑树保证了迭代的顺序和稳定性。

#### 适用场景：

- 当需要保持元素有序时使用`std::map`。
- 适用于需要频繁的范围查询（如下限和上限）等操作。

### 2. `std::unordered_map`

#### 实现方式：

- `std::unordered_map`是使用 **哈希表** 实现的。
- 哈希表使用哈希函数将键映射到哈希桶（bucket）中，从而实现快速查找。
- 每个哈希桶内部可能会使用链表或其他结构来处理哈希冲突（collision），如链地址法（链表）或开放地址法。

#### 特性：

- **无序性**：`std::unordered_map`中的元素是无序的，元素顺序完全由哈希函数和哈希冲突的处理方式决定。
- **时间复杂度**：在理想情况下（哈希函数均匀分布、冲突少），查找、插入和删除操作的平均时间复杂度为 **O(1)**。最坏情况下（所有元素都哈希到同一个桶）复杂度为 **O(n)**。
- **内存使用**：`std::unordered_map`通常需要额外的空间来存储哈希桶，但在大多数情况下，其内存效率比平衡树要高。
- **迭代顺序不稳定**：由于元素顺序是基于哈希函数的，因此迭代顺序不稳定且不可预测。

#### 适用场景：

- 当键的顺序不重要且更注重性能时使用`std::unordered_map`。
- 适用于需要快速查找的场景。



## map中大于某值的第一个元素？upper_bound

```cpp
#include <iostream>
#include <map>

int main() {
    // 创建一个map并插入一些元素
    std::map<int, std::string> myMap;
    myMap[1] = "one";
    myMap[3] = "three";
    myMap[5] = "five";
    myMap[7] = "seven";

    int value = 4; // 我们要查找大于这个值的第一个元素
    auto it = myMap.upper_bound(value);

    if (it != myMap.end()) {
        std::cout << "The first element greater than " << value << " is: ";
        std::cout << it->first << " => " << it->second << std::endl;
    } else {
        std::cout << "No element greater than " << value << " was found." << std::endl;
    }

    return 0;
}
```





## Linux命令行查找某个单词？grep

`grep` 

**基本用法：**

```shell
grep "单词" 文件名
```

**示例：**

查找 `example.txt` 文件中包含 `hello` 的行：

```shell
grep "hello" example.txt
```

**常用选项：**

- `-i`：忽略大小写。
- `-r` 或 `-R`：递归搜索目录中的所有文件。
- `-n`：显示匹配行的行号。
- `-w`：匹配整个单词。
- `-l`：只显示包含匹配内容的文件名。
- `-v`：显示不匹配的行。

![1725807702358](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\1725807702358.png)



## Linux如何查看磁盘的占用情况？

`df -h`

![1725716910239](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\1725716910239.png)

**1. /dev/sda2**:

- **大小 (Size)**: 20G
- **已用空间 (Used)**: 11G
- **可用空间 (Avail)**: 7.8G
- **使用率 (Use%)**: 59%
- **挂载点 (Mounted on)**: `/`

这是主要的根分区（/），总容量为 20GB，目前已使用 11GB，剩余 7.8GB。使用率为 59%，还有相当的可用空间，不需要立即扩容。

**2. tmpfs**:

- 这些是临时文件系统，通常用于系统内存分配。
- `/run` 挂载的 tmpfs 大小为 790M，使用 5.3M，剩余 785M。
- `/dev/shm` 挂载的 tmpfs 大小为 3.9G，未使用任何空间。
- `/run/lock` 挂载的 tmpfs 大小为 5.0M，使用了 8.0K，几乎未占用空间。
- `/run/user/1000` 挂载的 tmpfs 大小为 790M，使用了 120K，几乎未占用空间。





## 反问
- 部门业务？消费者bg，大模型相关
- base？合肥


