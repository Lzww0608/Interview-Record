# 用友C++提前批20240726

无手撕，面试官上来问我Java八股我直接说我不会Java，面试官有点尴尬，就问了我半小时中间件就结束了。

问题整理：

1.自我介绍

## 2.redis基本数据结构，Zset底层结构，跳表原理

SDS, List, Hash, Set, ZSet



## 3.redis读写会有风险吗

+ 一致性：开启事务、分布式锁
+ 持久性： AOF + ADB
+ 慢查询、大KEY、内存耗尽（内存淘汰）



## 4.redis set NX 实现分布式锁的风险

+ 锁释放时间不当，业务未执行完锁就释放：看门狗机制 + Lua脚本
+ 单节点宕机：RedLock
+ 可重入性：记录可重入次数



5.redis集群多主多从



## 6.mq消息积压怎么处理

+ 消费者水平扩容
+ 消费端降级、生产端限流



## 7.mq消息持久化

Kafka：

+ 分区日志、顺序写入、文件分段

- **写操作流程：**
  1. 生产者发送消息到Broker。
  2. Broker接收到消息后，并**不是直接写入磁盘（fsync）**，而是先将消息写入到**操作系统的页缓存（Page Cache）**中。
  3. 写入Page Cache后，Broker就可以向生产者返回ACK（确认），表示消息已“接收”。
  4. 操作系统会根据自己的调度策略（如pdflush守护进程），在后台异步地将Page Cache中的脏数据刷写（flush）到磁盘。



8.介绍一下微服务架构

## 9.限流怎么实现





## 10.数据库层面用的锁有哪些

好的，面试官。数据库锁是保证数据并发访问时一致性的核心机制，也是面试中经常考察的深层次知识点。我会从**锁的粒度**和**锁的类型**这两个维度，结合主流关系型数据库（特别是MySQL的InnoDB引擎）的实现，来系统地阐述数据库层面的锁。

---

### 一、 按锁的粒度划分

锁的粒度决定了锁定的数据范围大小。粒度越大，并发性能越差，但管理开销小；粒度越小，并发性能越好，但管理开销大，且容易产生死锁。

#### 1. 表级锁（Table-level Locking）
*   **概念**：对整张表加锁。当一个会话对表进行写操作时（如`INSERT`, `UPDATE`, `DELETE`），它会获得一个写锁，阻塞其他所有会话对该表的读写操作。当一个会话进行读操作时，它会获得一个读锁，阻塞其他会话的写操作，但不阻塞读操作。
*   **特点**：
    *   **优点**：实现简单，开销小，不会产生死锁。
    *   **缺点**：并发度最低，因为锁定的范围太大了。
*   **引擎代表**：MySQL的**MyISAM**、MEMORY引擎。
*   **手动加锁**：`LOCK TABLES table_name [READ | WRITE];` 和 `UNLOCK TABLES;`

#### 2. 页级锁（Page-level Locking）
*   **概念**：对数据存储的“页”（Page）进行加锁。页是数据库管理磁盘的最小单位，通常是4KB、8KB或16KB。
*   **特点**：
    *   并发性能和开销介于表锁和行锁之间。
    *   也存在死锁的可能性。
*   **引擎代表**：SQL Server早期版本，以及MySQL的**BDB**引擎（已不常用）。

#### 3. 行级锁（Row-level Locking）
*   **概念**：对数据表中的**某一行或某几行**进行加锁。这是锁粒度中最细的一种。
*   **特点**：
    *   **优点**：并发性能最高，因为它只锁定需要操作的数据行，最大程度地支持并发访问。
    *   **缺点**：实现复杂，开销最大（需要更多的内存来管理锁信息），并且最容易发生死锁。
*   **引擎代表**：**InnoDB**（MySQL的默认引擎）、PostgreSQL、Oracle等现代关系型数据库的主流选择。

**重点：InnoDB的行锁是基于索引实现的。**
*   如果一条SQL语句**命中了索引**，那么它会锁定索引记录（index record），这被称为**记录锁（Record Lock）**。
*   如果一条SQL语句**没有命中索引**，导致了全表扫描，那么InnoDB会退化为**给表中的每一行都加上行锁**，这在效果上约等于一个**表锁**，并发性能会急剧下降。这是开发中需要极力避免的情况。

---

### 二、 按锁的类型（或模式）划分

这是更核心、更复杂的分类，主要针对InnoDB引擎。

#### 1. 共享锁（Shared Lock，S锁）与排他锁（Exclusive Lock，X锁）
这是最基本的两种锁模式，也常被称为**读锁**和**写锁**。

*   **共享锁（S锁）**：
    *   **作用**：一个事务对某行数据加上S锁后，**允许其他事务再对该行加S锁**（读读可以并行），但**不允许其他事务对该行加X锁**（读写阻塞）。
    *   **获取方式**：普通的`SELECT`语句在**读已提交（RC）**和**可重复读（RR）**隔离级别下，默认不加锁（通过MVCC实现非阻塞读）。需要手动加锁：
        ```sql
        SELECT ... LOCK IN SHARE MODE; -- 在MySQL 8.0之前
        SELECT ... FOR SHARE;         -- MySQL 8.0+
        ```

*   **排他锁（X锁）**：
    *   **作用**：一个事务对某行数据加上X锁后，**不允许任何其他事务再对该行加任何锁（S锁或X锁）**。即“写写阻塞”和“写读阻塞”。
    *   **获取方式**：
        *   `INSERT`, `UPDATE`, `DELETE`等写操作会自动为涉及的行加上X锁。
        *   手动加锁：`SELECT ... FOR UPDATE;`

**兼容性矩阵：**

| -       | S锁  | X锁  |
| :------ | :--- | :--- |
| **S锁** | 兼容 | 冲突 |
| **X锁** | 冲突 | 冲突 |

#### 2. 意向锁（Intention Lock）
意向锁是一种**表级锁**，但它的作用非常特殊，是为了**协调表锁和行锁的关系**，提高加表锁的效率。它是由InnoDB自动管理的，用户无法干预。

*   **意向共享锁（IS锁）**：当一个事务准备对某几行加**S锁**时，它必须先在**表级别**获取一个IS锁。
*   **意向排他锁（IX锁）**：当一个事务准备对某几行加**X锁**时，它必须先在**表级别**获取一个IX锁。

**为什么需要意向锁？**
想象一个场景：事务A想给整张表加一个表级的X锁 (`LOCK TABLES ... WRITE`)。如果没有意向锁，它需要遍历表中的每一行，检查是否有行锁存在，这效率极低。

有了意向锁后，流程变为：
1.  事务A想加表级X锁，它只需检查表上是否有**任何类型**的意向锁（IS或IX）或其他表锁。
2.  如果此时事务B正持有着某一行的行锁（S或X），那么它必然已经在表上持有了相应的意向锁（IS或IX）。
3.  事务A检查到表上有意向锁，就知道表里肯定有行锁，于是它就阻塞等待，无需再遍历每一行。

**兼容性矩阵（包含意向锁）：**

| -      | IS   | IX   | S    | X    |
| :----- | :--- | :--- | :--- | :--- |
| **IS** | 兼容 | 兼容 | 兼容 | 冲突 |
| **IX** | 兼容 | 兼容 | 冲突 | 冲突 |
| **S**  | 兼容 | 冲突 | 兼容 | 冲突 |
| **X**  | 冲突 | 冲突 | 冲突 | 冲突 |

#### 3. InnoDB特有的行锁算法（非常重要）

在可重复读（RR）隔离级别下，为了解决幻读问题，InnoDB引入了更复杂的行锁算法。

*   **记录锁（Record Lock）**：
    *   这是最简单的行锁，它锁定的是**单个索引记录**。
    *   例如 `SELECT * FROM t WHERE id = 1 FOR UPDATE;` 会在`id=1`的索引记录上加一个X锁。

*   **间隙锁（Gap Lock）**：
    *   **概念**：锁定一个**索引记录之间的开区间**，不包括记录本身。它的唯一目的就是**防止其他事务在这个间隙中插入新的记录**，从而防止幻读。
    *   **触发条件**：在使用**范围查询**（如 `BETWEEN`, `>`, `<`）或**查找不存在的记录**时，并且查询条件命中了索引。
    *   **示例**：表中有id为10和20的记录。`UPDATE t SET name = 'x' WHERE id > 10 AND id < 20;` 这条语句会锁定 `(10, 20)` 这个开区间。此时，任何事务都无法插入`id=11`或`id=19`的记录，但可以修改`id=10`的记录。
    *   **注意**：间隙锁之间是**互相兼容**的，即一个事务持有的间隙锁，不会阻塞另一个事务在同一个间隙上加间隙锁。

*   **临键锁（Next-Key Lock）**：
    *   **概念**：它是**记录锁和间隙锁的结合体**，锁定一个**左开右闭**的区间。
    *   **公式**：`Next-Key Lock = Record Lock + Gap Lock`
    *   **作用**：InnoDB在**可重复读（RR）隔离级别**下，默认使用的就是临键锁。它既锁定了记录本身，也锁定了记录之前的间隙。
    *   **示例**：表中有id为10和20的记录。`SELECT * FROM t WHERE id = 10 FOR UPDATE;` 实际上加的临键锁会覆盖 `(负无穷, 10]` 这个区间。`SELECT * FROM t WHERE id > 10 AND id < 20 FOR UPDATE;` 会锁定 `(10, 20]` 这个区间。
    *   **优化**：当查询是**唯一索引的等值查询**且记录存在时，Next-Key Lock会退化为Record Lock，因为不需要保护间隙。

#### 4. 插入意向锁（Insert Intention Lock）
*   这是一种特殊的**间隙锁**，是`INSERT`操作在插入一条记录前设置的。它表示一个插入的“意图”，如果多个事务同时想在同一个间隙内插入数据，但插入的位置不冲突，那么它们互相之间**不会阻塞**。

#### 5. 自增锁（AUTO-INC Lock）
*   这是一种特殊的**表级锁**，用于处理自增（`AUTO_INCREMENT`）列。当一个事务插入带有自增列的记录时，会获取这个锁，以保证分配的自增ID是连续且唯一的。在MySQL 5.1.22之后，InnoDB引入了更轻量级的互斥量（mutex）来优化自增锁的性能，减少了锁的持有时间。

### 总结

面试官，数据库层面的锁是一个复杂的体系，我们可以这样归纳：

1.  **从宏观（粒度）上看**：有**表锁**（MyISAM）、**页锁**（BDB）和**行锁**（InnoDB）。InnoDB是目前的主流，它以行锁为主，但在特定情况下（如无索引的全表扫描）会升级为事实上的表锁。

2.  **从微观（类型）上看**：
    *   最基础的是**共享锁（S）**和**排他锁（X）**，规定了读写的基本并发规则。
    *   为了协调表锁和行锁，InnoDB自动引入了**意向锁（IS/IX）**，这是一种表级锁。
    *   为了在**可重复读**隔离级别下解决**幻读**问题，InnoDB在行锁的基础上，设计了三种精细的算法：
        *   **记录锁（Record Lock）**：锁单条记录。
        *   **间隙锁（Gap Lock）**：锁记录之间的间隙。
        *   **临键锁（Next-Key Lock）**：记录锁 + 间隙锁，是RR级别下的默认策略。

理解这些锁的机制，对于我们编写高性能、高并发的SQL，以及排查和解决死锁问题，具有至关重要的指导意义。



11.超买超卖如何避免

12.mysql 乐观锁实现

13.mysql索引，索引下推



## 14.MVCC





## 15.mysql 日志有哪些

+ redo log
+ undo log
+ bin log 二进制
+ error log



## 16.mysql集群

+ 分布式分片节点
+ SQL节点
+ 管理节点