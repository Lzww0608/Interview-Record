# 360C++实习一面20250626

1.自我介绍

## 2.extern，为什么要加extern，linux命令nm



3.为什么构造函数不能虚拟化

4.纯虚函数和虚函数区别，应用，虚函数表，指针
5.进程、线程

## 6.常用容器，vector和list区别，resize和reserve区别，erase底层



7.编程：一个随机数数组，删除3的倍数的值
我：遍历删除
hr：如何优化？想想erase底层，优化代码
我：把3的倍数的数整体移到最后再删除
8.僵尸进程和孤儿进程

## 9.进程间通信方式？Linux中“|”是无名管道还是有名管道？“|”调用了哪些调用？为什么前一个命令的结果不输出在屏幕？

### 1. `|` 是无名管道 (Anonymous Pipe)

Linux中的管道符 `|` 创建的是**无名管道**，也叫**匿名管道**。

我们可以从以下几个关键特征来区分它和有名管道（FIFO）：

*   **生命周期**：无名管道是**临时的**，它的存在完全依赖于内核。它随着创建它的进程（以及其子进程）的生命周期的结束而自动消失。它没有实体文件存在于文件系统中。
*   **通信范围**：无名管道只能用于**具有亲缘关系**的进程之间进行通信，最典型的就是父子进程或兄弟进程。因为只有亲缘进程才能继承得到指向管道两端的文件描述符。
*   **创建方式**：通过 `pipe()` 系统调用在内存中创建。

相比之下，**有名管道（FIFO）**：
*   **生命周期**：是**持久的**，它以一个特殊文件的形式存在于文件系统中，除非被显式删除，否则一直存在。
*   **通信范围**：可以用于**任何两个不相关的进程**之间通信，只要它们知道这个管道文件的路径并且有相应的读写权限。
*   **创建方式**：通过 `mkfifo` 命令或 `mkfifo()` 系统调用创建。

因此，Shell中用于连接两个命令的 `|`，其作用是临时地将一个进程的输出连接到另一个进程的输入，这正是无名管道的典型应用场景。

---

### 2. `|` 背后的系统调用序列

当你在Shell中执行一条命令如 `ls -l | grep "test"` 时，Shell（比如`bash`）作为父进程，在幕后精心编排了一系列系统调用来完成这个任务。这个过程是理解Linux进程模型的绝佳案例：

1.  **`pipe()`**：Shell首先调用 `pipe()` 系统调用，创建一个无名管道。
    ```c
    int pipefd[2];
    pipe(pipefd); 
    // pipefd[0] 是管道的读取端 (read end)
    // pipefd[1] 是管道的写入端 (write end)
    ```
    此时，Shell进程自身持有了这个管道的两端文件描述符。

2.  **`fork()`** (第一次)：Shell调用 `fork()` 创建第一个子进程，用于执行 `ls -l`。

3.  **在第一个子进程中 (`ls -l` 的进程)**：
    *   **关闭不需要的描述符**：这个进程只需要向管道写入数据，所以它会关闭管道的读取端：`close(pipefd[0]);`。
    *   **`dup2()` (重定向)**：这是最关键的一步。它调用 `dup2(pipefd[1], STDOUT_FILENO);`。`STDOUT_FILENO` 是一个值为1的宏，代表标准输出。这个调用的作用是复制 `pipefd[1]` 到文件描述符1，从而**将该进程的标准输出重定向到管道的写入端**。之后，任何写入标准输出的数据，实际上都会被写入管道。
    *   **关闭旧的描述符**：重定向完成后，原始的 `pipefd[1]` 就可以关闭了：`close(pipefd[1]);`。
    *   **`execve()`**：最后，子进程调用 `execve()` (或其变体如 `execlp`) 来执行 `ls` 命令。`execve` 会用新的程序（`ls`）替换当前进程的内存空间，但**文件描述符表会被继承**。因此，`ls` 程序一启动，它的标准输出就已经被重定向到了管道。

4.  **`fork()`** (第二次)：Shell（父进程）再次调用 `fork()` 创建第二个子进程，用于执行 `grep "test"`。

5.  **在第二个子进程中 (`grep` 的进程)**：
    *   **关闭不需要的描述符**：这个进程只需要从管道读取数据，所以它会关闭管道的写入端：`close(pipefd[1]);`。
    *   **`dup2()` (重定向)**：同样关键的一步。它调用 `dup2(pipefd[0], STDIN_FILENO);`。`STDIN_FILENO` 是一个值为0的宏，代表标准输入。这会将该进程的**标准输入重定向到管道的读取端**。之后，任何从标准输入的读取操作，实际上都是从管道中读取数据。
    *   **关闭旧的描述符**：`close(pipefd[0]);`。
    *   **`execve()`**：子进程调用 `execve()` 来执行 `grep` 命令。`grep` 启动后，它的标准输入就已经被重定向到了管道。

6.  **在父进程 (Shell) 中**：
    *   **关闭管道两端**：Shell自身既不读也不写这个管道，所以它必须关闭它持有的两个文件描述符：`close(pipefd[0]);` 和 `close(pipefd[1]);`。这一点至关重要，如果不关闭，可能会导致子进程无法正常结束（比如读管道的进程永远等不到EOF）。
    *   **`waitpid()`**：Shell调用 `waitpid()` 等待两个子进程都执行完毕，然后才返回并显示新的命令提示符。

---

### 3. 为什么前一个命令的结果不输出在屏幕？

这个问题的答案，就隐藏在上述第3步的 **`dup2()` 系统调用**中。

在Linux（以及所有Unix-like系统）中，每个进程都维护着一张**文件描述符表**。默认情况下：
*   文件描述符 **0** 指向 **标准输入 (stdin)**，通常是键盘。
*   文件描述符 **1** 指向 **标准输出 (stdout)**，通常是终端屏幕。
*   文件描述符 **2** 指向 **标准错误 (stderr)**，通常也是终端屏幕。

当 `ls -l` 这个进程执行 `dup2(pipefd[1], STDOUT_FILENO)` 时，它实际上修改了自己进程内部的文件描述符表。这个操作使得**文件描述符 1 不再指向终端屏幕，而是指向了管道的写入端**。

所以，当 `ls` 程序内部调用 `write(1, "...", ...)` 或 `printf(...)` （其底层会调用 `write(1, ...)`）试图将结果输出到它的标准输出时：
*   内核查找该进程的文件描述符表，发现文件描述符1对应的不再是终端设备。
*   内核将数据路由到文件描述符1现在指向的目标——**无名管道的内核缓冲区**中。

数据就这样被悄无声息地送入了管道，而不是显示在屏幕上。随后，管道另一端的 `grep` 进程从它的标准输入（已经被重定向到管道的读取端）读取这些数据进行处理，并将其处理结果输出到它自己的标准输出（默认情况下是终端屏幕）。

**总结一下：前一个命令的结果没有输出在屏幕上，是因为它的标准输出流在进程层面被重定向了，数据流向了管道，而不是终端。这是通过 `dup2` 系统调用实现的，是Linux/Unix实现强大命令行组合能力的核心机制。**



10.C++写过锁了吗？
11.如何测试内存性能，如何评价性能强弱

## 12.Shell脚本set -e作用



## 13.Shell脚本连接服务器进行很久的操作时，网络若不稳定，如何保证脚本的运行？（放后台）



14.网络编程相关
15.Ping用的什么协议
16.http，了解哪些返回码？比如404，403等等
17.raii接触过吗？