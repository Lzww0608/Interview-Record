# 字节C++四面20250508

14号笔试，20号面试，上周三接到了了解信息的电话，今天凌晨改了头像许愿，今天上午终于接到了offer call

base 上海 后台开发 貌似是广告部门

下面发一个面经

### 一面：

自我介绍，问了下毕设项目（一个机器学习应用项目，输入输出是什么，怎么应用的）

开始问问题

**操作系统：**

调度的基本单位是什么



## 阻塞IO 非阻塞IO说一下（说了5种IO模型，详细说了下io复用）

**阻塞I/O模型 (Blocking I/O - BIO)**

- **工作原理**：当用户进程发起一个I/O操作（如`recvfrom`）时，如果内核数据还没有准备好，那么整个用户进程就会被阻塞，直到数据准备好并从内核复制到用户空间完成，该调用才会返回。
- **优点**：模型简单，易于理解和编程。
- **缺点**：并发能力差，因为一个线程在等待I/O时不能做其他任何事情。如果需要处理大量并发连接，就需要创建大量线程，导致系统开销巨大（线程上下文切换、内存占用等）。

**非阻塞I/O模型 (Non-blocking I/O - NIO)**

- **工作原理**：当用户进程发起一个I/O操作时，如果内核数据还没有准备好，调用会立即返回一个错误（例如`EWOULDBLOCK`或`EAGAIN`），而不会阻塞用户进程。用户进程需要不断地轮询（polling）内核，询问数据是否准备好。当数据准备好后，再发起系统调用将数据从内核复制到用户空间，这个复制过程仍然是阻塞的。
- **优点**：相比阻塞I/O，进程在等待数据期间不会被完全阻塞，可以执行其他任务。
- **缺点**：轮询会消耗大量CPU时间，效率不高。数据复制阶段仍然是阻塞的。

**I/O多路复用模型 (I/O Multiplexing)**

- **工作原理**：此模型引入了一种机制（如`select`、`poll`、`epoll`），允许单个进程/线程监视多个文件描述符（socket）。用户进程首先将关心的文件描述符注册到复用器上。然后，进程会阻塞在复用器的调用上（如`select`）。当任何一个或多个文件描述符准备好进行I/O操作（可读、可写或异常）时，复用器调用就会返回，并告知哪些描述符已就绪。然后用户进程再针对这些就绪的描述符发起实际的I/O操作（通常是非阻塞的读写），将数据从内核复制到用户空间。
- **优点**：可以用较少的线程处理大量的并发连接，系统开销小，效率高。`epoll`相较于`select`和`poll`有更高的性能，因为它只关心活跃的连接，并且采用事件驱动的方式。
- **缺点**：编程复杂度相较于阻塞I/O有所增加。`select`和`poll`在大量连接时性能会有所下降（`select`有连接数限制，`poll`没有但仍需轮询所有连接）。

**信号驱动I/O模型 (Signal-driven I/O)**

- **工作原理**：用户进程开启套接口的信号驱动I/O功能，并通过`sigaction`系统调用预先注册一个信号处理函数。当数据准备好时，内核会为该进程产生一个`SIGIO`信号。用户进程可以在信号处理函数中调用I/O操作（如`recvfrom`）来读取数据。数据从内核复制到用户空间的过程仍然是阻塞的。
- **优点**：在等待数据阶段，进程不会被阻塞，可以执行其他任务。
- **缺点**：信号处理机制在处理大量`SIGIO`信号时可能变得复杂和低效。数据复制阶段仍然是阻塞的。在实践中，这种模型用得不如I/O多路复用普遍。

**异步I/O模型 (Asynchronous I/O - AIO)**

- **工作原理**：用户进程发起一个异步I/O操作后，调用会立即返回，进程不会被阻塞。内核会在后台完成所有I/O操作（包括等待数据和将数据从内核复制到用户空间）。当整个I/O操作完成后，内核会通知用户进程（例如通过信号、回调函数或事件）。
- **优点**：真正的非阻塞，并发性能高。应用代码逻辑相对简单，因为不需要自己处理等待和数据复制的阻塞。
- **缺点**：实现和调试相对复杂。在Linux下，早期的AIO支持并不完善（例如，可能依赖用户态线程模拟），但现代Linux内核（如通过`io_uring`）提供了更高效的异步I/O实现。



## 进程状态都有哪些，怎么转换

进程在其生命周期中会经历多种状态，这些状态反映了进程当前的活动和能否被CPU调度执行的情况。常见的进程状态及其转换如下：

**一、主要的进程状态**

1. **新建态 (New)**：
   - 进程刚刚被创建，操作系统已为其分配了必要的资源（如进程控制块PCB），但尚未被批准投入运行。
   - 可以理解为进程正在被创建的过程。
2. **就绪态 (Ready)**：
   - 进程已经具备了运行所需的所有条件（除了CPU），它在主存储器中，等待被CPU调度执行。
   - 系统会将所有处于就绪态的进程组织成一个或多个就绪队列。
3. **运行态 (Running)**：
   - 进程获得了CPU，其指令正在被执行。
   - 在单处理器系统中，任何时刻最多只有一个进程处于运行态。在多处理器系统中，则可以有多个进程同时处于运行态。
4. **阻塞态 (Blocked) 或 等待态 (Waiting)**：
   - 进程因为等待某一事件的发生而暂时停止执行，例如等待I/O操作完成、等待某个信号、等待获得锁资源等。
   - 即使CPU空闲，处于阻塞态的进程也不能运行。
5. **终止态 (Terminated) 或 退出态 (Exit)**：
   - 进程已经完成了它的执行，或者被操作系统强制终止。
   - 此时，进程占有的资源会被回收，但其进程控制块（PCB）可能还会保留一段时间，以便父进程或其他相关进程读取其退出状态。当PCB也被清除后，进程才算完全消失。

**二、进程状态之间的转换**

进程状态之间的转换是由特定的事件或操作系统调度行为触发的：

1. **新建态 -> 就绪态**：
   - 当操作系统完成了进程创建的初始化工作，并接纳该进程后，进程从新建态转换为就绪态，等待被调度。
2. **就绪态 -> 运行态**：
   - 当操作系统的调度程序（Scheduler）选择了一个就绪态的进程来占用CPU时，该进程就从就绪态转换为运行态。这通常被称为“**调度（Dispatch）**”。
3. **运行态 -> 就绪态**：
   - 这通常发生在以下情况： 
     - **时间片用完**：在分时系统中，当一个运行中的进程用完了分配给它的CPU时间片，调度程序会剥夺其CPU使用权，使其返回到就绪态，等待下一次调度。
     - **高优先级进程抢占**：如果一个更高优先级的进程变为就绪态，调度程序可能会抢占当前运行进程的CPU，使其回到就绪态。
4. **运行态 -> 阻塞态**：
   - 当一个正在运行的进程需要等待某个外部事件才能继续执行时，它会从运行态转换为阻塞态。例如： 
     - 请求I/O操作（如读写文件、网络请求）。
     - 请求获取一个当前不可用的资源（如锁、信号量）。
     - 主动调用`sleep`等函数使自己挂起。
   - 这个转换是进程主动请求的。
5. **阻塞态 -> 就绪态**：
   - 当进程等待的事件发生或条件满足时（例如I/O操作完成、请求的资源可用、定时器超时），操作系统会将该进程从阻塞态唤醒，并将其置于就绪态。
   - **注意**：通常情况下，阻塞的进程在事件完成后不会直接回到运行态，而是回到就绪态，等待调度程序再次分配CPU。
6. **运行态 -> 终止态**：
   - 当进程完成了其指定的任务，执行了退出指令（如`exit()`系统调用），或者发生了无法恢复的错误（如非法内存访问、除零错误），或者被其他有权限的进程（如父进程或管理员）杀死时，进程会从运行态转换为终止态。



## 调度算法都有什么，调度的时机是什么

1. **先来先服务 (First-Come, First-Served - FCFS)**
   - **原理**：按照进程到达就绪队列的先后顺序进行调度。一旦一个进程获得了CPU，它会一直运行直到完成或因I/O阻塞。
   - **优点**：简单，易于实现，公平（直观上的）。
   - **缺点**：平均等待时间可能很长，特别是当一个长作业先到达时，会导致后续短作业长时间等待（称为“护航效应”）。不利于交互式系统。
   - **类型**：非抢占式。
2. **最短作业优先 (Shortest Job First - SJF)**
   - **原理**：选择就绪队列中预计运行时间最短的进程投入运行。
   - **优点**：理论上可以证明其平均等待时间最短，吞吐量高。
   - 缺点： 
     - 难以准确预测进程的运行时间。
     - 可能导致长作业“饿死”，即长时间得不到CPU。
   - 类型： 
     - **非抢占式SJF**：一旦进程获得CPU，会一直运行到完成或阻塞。
     - **抢占式SJF (也称最短剩余时间优先 - Shortest Remaining Time First, SRTF)**：当一个新到达的进程的预计运行时间比当前正在运行进程的剩余运行时间还要短时，会抢占CPU。
3. **优先级调度 (Priority Scheduling)**
   - **原理**：为每个进程分配一个优先级，调度程序选择具有最高优先级的就绪进程。优先级可以静态分配（创建时确定，不再改变）或动态分配（根据进程行为调整）。
   - **优点**：可以满足紧迫任务的需求，灵活性高。
   - **缺点**：可能导致低优先级进程“饿死”。解决方法之一是“老化”(Aging)，即逐步提高等待时间较长的低优先级进程的优先级。
   - **类型**：可以是抢占式的，也可以是非抢占式的。抢占式优先级调度允许高优先级进程抢占正在运行的低优先级进程。
4. **时间片轮转 (Round Robin - RR)**
   - **原理**：主要为分时系统设计。每个进程被分配一个固定的时间单元，称为时间片（Quantum）。进程运行一个时间片后，如果还未完成，则被置于就绪队列的末尾，CPU被分配给队列中的下一个进程。
   - **优点**：公平，响应时间较快，适用于交互式系统。
   - 缺点： 
     - 时间片大小的选择很关键：太小会导致频繁的上下文切换，开销大；太大则可能退化为FCFS。
     - 平均周转时间通常比SJF长。
   - **类型**：抢占式（基于时间片中断）。
5. **多级队列调度 (Multilevel Queue Scheduling)**
   - **原理**：将就绪队列划分为多个独立的队列，每个队列有自己的调度算法（如前台队列用RR，后台批处理队列用FCFS）。进程根据其特性（如交互型、批处理型、系统进程）被永久分配到某个队列。队列之间通常也有优先级。
   - **优点**：可以针对不同类型的进程采用不同的调度策略，灵活性高。
   - **缺点**：如果队列间优先级固定，低优先级队列中的进程可能饿死。进程不能在队列间移动。
6. **多级反馈队列调度 (Multilevel Feedback Queue Scheduling)**
   - 原理：允许多个就绪队列，并且允许进程在队列之间移动。这是最通用的CPU调度算法之一，可以配置以适应各种情况。 
     - 新进程通常进入优先级较高的队列（时间片较小）。
     - 如果在时间片内未完成，则移到优先级较低的队列（时间片可能更大）。
     - 在低优先级队列中等待时间过长的进程可能会被移回高优先级队列（防止饿死）。
   - **优点**：非常灵活，可以同时兼顾周转时间、响应时间和公平性，能有效防止饿死。
   - **缺点**：设计和调优参数（队列数量、各队列调度算法、时间片大小、升级降级策略）比较复杂。
   - **类型**：抢占式。
7. **最高响应比优先 (Highest Response Ratio Next - HRRN)**
   - **原理**：这是一种对SJF的改进，试图平衡短作业和长作业。它计算每个进程的响应比：`响应比 = (等待时间 + 服务时间) / 服务时间`。选择响应比最高的进程。
   - **优点**：短作业因为服务时间小，响应比较高，容易被选中；长作业等待时间增加后，响应比也会提高，避免了饿死。
   - **缺点**：每次调度前需要计算所有就绪进程的响应比，有一定开销。需要预估服务时间。
   - **类型**：非抢占式。

**二、调度的时机 (Scheduling Points/Triggers)**

调度的时机是指操作系统内核在什么时候会调用调度程序来决定下一个要运行的进程。主要有以下几种情况：

1. **进程创建 (Process Creation)**：

   - 当一个新进程被创建并进入就绪态时，调度程序可能需要决定是继续运行父进程还是运行子进程，或者选择其他就绪进程。

2. **进程终止 (Process Termination)**：

   - 当一个进程执行完毕或被强制终止时，它会释放CPU。此时，操作系统必须选择另一个就绪进程来运行。这是所有调度算法都会发生的调度点。

3. **进程从运行态转为阻塞态 (Running -> Blocked/Waiting)**：

   - 当一个正在运行的进程因为等待某个事件（如I/O操作、等待锁、调用`sleep()`）而无法继续执行时，它会主动放弃CPU进入阻塞态。此时调度程序必须选择另一个进程运行。这也是所有调度算法都会发生的调度点。

4. **进程从阻塞态转为就绪态 (Blocked/Waiting -> Ready)**：

   - 当一个阻塞的进程所等待的事件发生时（如I/O操作完成），它会从阻塞态转为就绪态。
   - 在**抢占式调度**中，如果这个新进入就绪态的进程的优先级高于当前正在运行的进程，调度程序可能会剥夺当前进程的CPU，转而运行这个新就绪的进程。
   - 在非抢占式调度中，即使新就绪的进程优先级更高，当前进程也会继续运行直到它自愿放弃CPU或终止。

5. **发生中断或异常 (Interrupt or Exception)**：

   - 当中断（如时钟中断、I/O中断）或异常发生时，CPU的控制权会转交给操作系统内核。

   - 在

     抢占式调度

     中，当中断处理完毕，返回用户态之前，调度程序可能会被调用。例如： 

     - **时钟中断**：在时间片轮转或抢占式优先级调度中，时钟中断发生时，如果当前进程的时间片用完，或者有更高优先级的进程在等待，就会发生调度。
     - **I/O中断**：如上述第4点，I/O完成后相关的进程可能从阻塞态变为就绪态，可能触发调度。

总结来说，调度的基本原则是：

- **非抢占式调度**：调度仅在进程终止或主动进入阻塞态时发生。
- **抢占式调度**：除了上述情况外，还可以在进程从阻塞态到就绪态、发生中断（特别是时钟中断导致时间片用完，或更高优先级进程就绪）时发生。



进程间通信方式都有哪些



**网络：**

## http长连接短连接说一下

Connection: Keep-Alive



## 路由器是哪一层的，有什么功能，路由寻址怎么找的，路由表存了什么

**路径选择 (Routing / Path Determination)**：这是路由器的核心智能所在。路由器通过运行各种路由协议（如RIP, OSPF, BGP, EIGRP等）或根据静态配置的路由信息，学习网络拓扑结构，并为数据包选择到达目标网络的最佳路径。

**数据包转发 (Packet Forwarding)**：当路由器接收到一个数据包后，它会检查数据包头中的目标IP地址，并根据其内部的路由表（Routing Table）来决定将数据包从哪个接口转发出去，以及下一跳（Next Hop）应该是哪个设备。

**连接不同网络 (Inter-Network Connectivity)**：路由器的根本目的是连接两个或多个逻辑上独立的IP网络（例如，连接你家的局域网和互联网服务提供商的网络，或者连接公司内部的不同部门子网）。

**隔离广播域 (Broadcast Domain Segmentation)**：路由器默认不会转发第二层（数据链路层）的广播帧（例如ARP请求或DHCP发现的广播）。每个路由器接口连接的网络都是一个独立的广播域，这有助于减少网络拥堵和提高网络效率。

**逻辑寻址 (Logical Addressing)**：路由器基于IP地址（逻辑地址）进行工作，而不是MAC地址（物理地址，由交换机在第二层使用）。

**网络地址转换 (Network Address Translation - NAT)**：许多家用和小型企业路由器会执行NAT，将内部私有IP地址转换成一个或多个公共IP地址，从而允许多个内部设备共享一个公共IP上网，并提供一定的安全屏障。

**访问控制和安全 (Access Control & Security)**：许多路由器支持访问控制列表（ACLs），可以根据源/目标IP地址、端口号、协议类型等过滤数据包，实现基本的防火墙功能。

**服务质量 (Quality of Service - QoS)**：一些高级路由器支持QoS功能，可以对不同类型的网络流量（如语音、视频、普通数据）进行优先级排序和带宽管理，以保证关键应用的性能。

**DHCP服务器 (Dynamic Host Configuration Protocol Server)**：许多家用或小型办公路由器内置DHCP服务器功能，可以自动为连接到其局域网的设备分配IP地址和其他网络配置信息。

好的，我们来详细了解一下路由器。

**1. 路由器是哪一层的？**

路由器主要工作在OSI七层参考模型中的**网络层 (Network Layer, Layer 3)**。在TCP/IP模型中，这对应的是**互联网层 (Internet Layer)**。

**2. 路由器有什么功能？**

路由器的核心功能是在不同的IP网络之间转发数据包，并为这些数据包选择最佳的传输路径。具体来说，其主要功能包括：

- **路径选择 (Routing / Path Determination)**：这是路由器的核心智能所在。路由器通过运行各种路由协议（如RIP, OSPF, BGP, EIGRP等）或根据静态配置的路由信息，学习网络拓扑结构，并为数据包选择到达目标网络的最佳路径。
- **数据包转发 (Packet Forwarding)**：当路由器接收到一个数据包后，它会检查数据包头中的目标IP地址，并根据其内部的路由表（Routing Table）来决定将数据包从哪个接口转发出去，以及下一跳（Next Hop）应该是哪个设备。
- **连接不同网络 (Inter-Network Connectivity)**：路由器的根本目的是连接两个或多个逻辑上独立的IP网络（例如，连接你家的局域网和互联网服务提供商的网络，或者连接公司内部的不同部门子网）。
- **隔离广播域 (Broadcast Domain Segmentation)**：路由器默认不会转发第二层（数据链路层）的广播帧（例如ARP请求或DHCP发现的广播）。每个路由器接口连接的网络都是一个独立的广播域，这有助于减少网络拥堵和提高网络效率。
- **逻辑寻址 (Logical Addressing)**：路由器基于IP地址（逻辑地址）进行工作，而不是MAC地址（物理地址，由交换机在第二层使用）。
- **网络地址转换 (Network Address Translation - NAT)**：许多家用和小型企业路由器会执行NAT，将内部私有IP地址转换成一个或多个公共IP地址，从而允许多个内部设备共享一个公共IP上网，并提供一定的安全屏障。
- **访问控制和安全 (Access Control & Security)**：许多路由器支持访问控制列表（ACLs），可以根据源/目标IP地址、端口号、协议类型等过滤数据包，实现基本的防火墙功能。
- **服务质量 (Quality of Service - QoS)**：一些高级路由器支持QoS功能，可以对不同类型的网络流量（如语音、视频、普通数据）进行优先级排序和带宽管理，以保证关键应用的性能。
- **DHCP服务器 (Dynamic Host Configuration Protocol Server)**：许多家用或小型办公路由器内置DHCP服务器功能，可以自动为连接到其局域网的设备分配IP地址和其他网络配置信息。

**3. 路由寻址怎么找的？（路由过程）**

当一个数据包到达路由器时，路由器的寻址（或称为路由决策和转发）过程大致如下：

1. **接收数据包**：数据包从路由器的某个物理接口进入。
2. **检查目标IP地址**：路由器解开数据包的第二层封装（如以太网帧头），查看其第三层头部信息，主要是**目标IP地址**。
3. 查询路由表 (Routing Table Lookup)： 
   - 路由器将其内部维护的路由表与数据包的目标IP地址进行匹配。
   - 这个匹配过程通常遵循“**最长前缀匹配 (Longest Prefix Match)**”原则。这意味着如果路由表中有多个条目都能匹配目标IP地址（例如，一个条目是`192.168.1.0/24`，另一个是`192.168.0.0/16`，而目标IP是`192.168.1.5`），路由器会选择子网掩码最长（即`/`后的数字最大，表示网络范围更具体）的那个条目。
4. 确定下一跳和出接口： 
   - 如果找到匹配的路由条目，该条目会告诉路由器将数据包转发到哪个**下一跳IP地址 (Next-Hop IP Address)** 以及应该从路由器的哪个**出接口 (Outgoing Interface)** 发送出去。
   - 如果目标网络是与路由器直接相连的，则下一跳可能为空或指向出接口本身，数据包将直接发送到该网络上的目标主机。
5. 封装和发送： 
   - 在将IP数据包发送到下一跳之前，路由器需要知道下一跳设备的第二层地址（MAC地址，如果下一跳在以太网段上）。
   - 路由器会查询其ARP缓存（ARP Cache，对于IPv4）或邻居缓存（Neighbor Cache，对于IPv6），寻找下一跳IP地址对应的MAC地址。
   - 如果缓存中没有，路由器会发送ARP请求（或NDP邻居请求）来获取MAC地址。
   - 一旦获得下一跳的MAC地址，路由器会用新的第二层帧头（包含下一跳的MAC地址作为目标MAC，路由器出接口的MAC地址作为源MAC）重新封装IP数据包，然后通过指定的出接口将帧发送出去。
   - **TTL递减**：在转发IP数据包之前，路由器通常会将其头部中的生存时间（Time To Live, TTL）字段的值减1。如果TTL变为0，数据包将被丢弃，并可能向源主机发送一个ICMP“超时”消息，以防止数据包在网络中无限循环。
6. 默认路由 (Default Route)： 
   - 如果在路由表中没有找到与目标IP地址匹配的条目，并且路由器配置了**默认路由**（通常是`0.0.0.0/0`），则数据包会被转发到默认路由指定的下一跳。默认路由通常指向互联网服务提供商（ISP）的路由器。
   - 如果没有匹配条目也没有默认路由，数据包将被丢弃，并且路由器通常会向源主机发送一个ICMP“目标不可达”的消息。





## ping协议会发生什么事情（当时以为问ICMP，结果下面引导到了dns）





dns协议，让后udp还是tcp



## http response里面都有哪些内容（大概说了一部分）

```http
HTTP/1.1 200 OK
Date: Thu, 08 May 2025 07:22:00 GMT
Server: MyCustomServer/1.0
Content-Type: text/html; charset=UTF-8
Content-Length: 138
Connection: keep-alive
Last-Modified: Wed, 07 May 2025 12:00:00 GMT
ETag: "abcdef123456"

<!DOCTYPE html>
<html>
<head>
  <title>Example Page</title>
</head>
<body>
  <h1>Hello, World!</h1>
  <p>This is a simple HTML page.</p>
</body>
</html>
```

**状态行 (Status Line)**

**响应头部 (Response Headers)**

**空行 (Empty Line)** (CRLF)

**响应正文 (Response Body / Message Body)** (可选)



**请求行 (Request Line)**

**请求头部 (Request Headers)**

**空行 (Empty Line)** (CRLF)

**请求正文 (Request Body / Message Body)** (可选)



**数据库：**

说一下数据库索引，然后说一下索引的优缺点



redis都有哪些数据类型（本来以为会展开问数据类型底层实现）



**编程题：**

反转链表，topk问题说思路、时间复杂度

### 二面：

二面的大佬真的好，问的所有问题，我如果说的不全面，他就给我补充了一点，不会的一个他也直接给我讲了一遍。

**操作系统：**

应该是看了一面的记录，然后问操作系统问的更深了一点



## 说一下进程线程，fork和vfork

**总结对比表：**

| 特性               | `fork()`                                 | `vfork()`                                              |
| ------------------ | ---------------------------------------- | ------------------------------------------------------ |
| **内存复制**       | 复制地址空间 (现代系统使用写时复制 COW)  | **不复制地址空间，共享父进程地址空间**                 |
| **父进程**         | 与子进程并发执行                         | **挂起直到子进程调用 exec() 或 _exit()**               |
| **子进程修改数据** | 修改的是自己的副本 (COW后)，不影响父进程 | **直接修改父进程的数据 (非常危险!)**                   |
| **主要用途**       | 创建通用子进程，执行不同任务或新程序     | **创建子进程后立即执行新程序 (exec())**                |
| **安全性**         | 相对安全                                 | **非常危险，容易出错，应谨慎使用**                     |
| **子进程返回**     | 可以从函数返回                           | **不能从创建它的函数返回，必须调用 _exit() 或 exec()** |



## fork时内存空间发生了哪些变化





## copy on write做了什么（这个之前没学到，大佬给我讲了一遍）

当父进程或子进程中的任何一个**尝试写入**某个共享的、被标记为只读的内存页时，会触发一个**页错误 (page fault)**。

内核捕获这个页错误，并执行以下操作： 

- 为试图写入的进程**分配一个新的物理内存页**。
- 将原始共享页的**内容复制到这个新分配的物理页**中。
- 更新该进程的页表条目，使其指向这个新的、私有的物理页。
- 将这个新的物理页标记为**可写 (writeable)**。
- 最后，在该新的私有页上执行之前被中断的写操作。

另一个进程（未执行写操作的那个）的页表条目仍然指向原始的共享物理页（如果该页没有被其他进程修改过，它可能仍然被标记为只读，或者如果只有一个进程引用它，则可能恢复其原始权限）。





进程的状态有哪些，怎么转换



## 等待态可以收到信号么（没了解过，大佬讲了一下S、D状态）

处于**可中断等待态**的进程**可以接收并响应信号**，信号会中断其等待状态。

处于**不可中断等待态**的进程通常**不会立即响应信号**，信号会被推迟到进程退出该状态后处理（少数特殊信号除外）。

处于**停止态**的进程**可以接收信号**，`SIGCONT` 会使其恢复，其他信号通常排队。

处于**僵尸态**的进程**不会处理任何信号**。



项目里用了IO复用，说一下select poll epoll（讲了区别，epoll底层数据结构，ET、LT）



死锁（死锁条件、避免死锁、死锁检测、死锁预防）



**网络：**

dns是tcp还是udp



## 说一下timewait和closewait（大佬讲了timewait中等待报文在网络中消失具体指的是路由器的缓存）





说一下拥塞控制



## udp报文最大长度（说了MTU1500，但是之前在网上看到过实际会更小，后来看到Internet是576）

以太网 MTU 通常为 1500 字节。

IPv4 头部通常为 20 字节。

UDP 头部为 8 字节。

那么，建议的 UDP 数据（payload）大小最好不要超过 1500−20−8=1472 字节。

这个 576 字节指的是整个 IP 数据报的大小，包括 IP 头部和 IP 数据部分（payload）。

这个规定的目的是为了确保 IP 数据报在互联网的不同网络之间传输时，即使遇到 MTU (Maximum Transmission Unit，最大传输单元) 较小的网络，也能保证最基本的数据包传递，而不需要进行分片（或者至少能处理这个大小的分片）。



**数据库：**

索引（讲的比一面更详细了一些）索引的使用条件 优化 最左原则

**编程题：**

二叉树Z字打印

一个从1开始的有序数组，找字典序第k大的数，说思路（leetcode440 没做过 提示了一下树，想出来了）

问了一下头条的技术栈。一面面试官说hr不让回答，二面大佬说头条大部分是Golang和C++（貌似Golang更多？）二面面试官是搞linux开发的大佬，人真的太好了。

### 三面：

三面上来就是问你最近做过的最有挑战最有意思的项目是什么（最近看CSAPP、unix网络编程写了一个http web server）

说一下内部具体流程吧

看你实现了一个线程池，用什么语言写的（c）那现场写一下吧（有点懵。。。回忆了一下写了主要的工作线程，线程池结构体，再加上口述和伪代码）

问了一下常用的语言（python做机器学习，c，Golang），可能跟面试官语言不匹配，没问问题

给了一个链表形式的有向无环图，然后求拓扑排序（最开始没注意到是链表，先说思路，说了传统的队列形式的做法，然后面试官提醒了这个数据结构，然后dfs写了一个）

设计一个内存池，满足内存申请、内存释放以及内存碎片管理等基本功能。（没了解过这个东西，然后感觉应该也是跟线程池类似的东西，想了一下每次申请一块内存，内部再分块，然后说了一下整体结构，怎么申请，怎么分配，碎片该怎么管理之类的，貌似中间面试官还笑了。。可能说得有点想当然了吧。。。）

最近看了什么非技术书。。。（一脸懵逼。。。哪有空看呐。。。其实有点想说睡前看网络小说可以么QAQ）

面完10分钟收到面试完成短信