# 字节C++暑期实习20250411

### 心得

先谈谈自己遇到的问题与从中总结的心得，不一定对每一个人都有用，当参考参考吧。

- 大家在找实习找工作时，可以稍微利用一些时间关注各个公司的招聘动态，据此编写一个进度表，如果有新的笔试、面试安排能够及时调整和筛选，大概什么时间点会面哪些公司，做到心中有数
- 如果复习的差不多了，我认为可以早点投
  - 一是因为，投递完简历之后，会有筛选、笔试或者捞了简历一直没发起面试等操作，要过一阵子才会真正开始面试，在这一段等待的时间里，其实也是可以复习的
  - 二是因为，你在复习，别人也在复习，等你复习差不多了，别人也复习差不多了，这时可能有很多HC就已经发出去了，越往后走可能难度越大
  - 我觉得我身边的同学、师弟一个月前就拿到了心仪offer时，我还在持续战斗的原因之一 ，可能就是投的比较晚了
- 有时候可能会接到没有预约的突然来电面试，此时如果允许的话，最好稍微推迟一点，做好心理准备、拿好纸笔、戴上耳机、尽快调整好进入状态、找一个较为安静的地方再开始面试，不然可能会影响面试质量
- 每次面试时最好是能够带上纸笔，面试官提问后，将其关键点在纸上做好记录
  - 一是因为，这样有助于思考，不熟悉的问题，可以有一小段时间回忆联想相关知识点，即使是很熟悉的问题，也不用急着马上回答，可以稍加梳理，快速在心里列出几个点，有条理有逻辑的述说
  - 二是因为，这些问题可能当时回答不完全，或者是根本不太会，在纸上记录后，可以在一定程度上复盘不会的点，从而利用闲余时间再将这些不足之处补上
- 在听到面试官问题后，最好先问清楚已知条件，根据已知条件作答，但同时也不要把条件问的太细，因为可能有反效果，把自己的思路、知识点限制得太窄
- 有一些开放性问题，不要觉得不熟悉、没听过，就想放弃，要敢于去尝试，去思考
  - 一是因为，根据自己的所学，慢慢回顾，以及在面试官的引导之下，是有可能回答出来的
  - 二是因为，有的开放性问题，本来就是面试官为了考察学生的知识广度、深度的，即使不会，在回答的过程也可以往自己会的知识点上引导，向面试官展现自己会的东西
- 心态很重要
  - 在招聘持续过程中，会经常与同学们交流，大家一起交流学习、面试心得是极好的，共同成长进步，但也难免会提到一些offer情况，不由自主的就比较一下啊，如果别人拿了好offer，而自己却不如意，心态上会很受影响，所以我觉得。。。（道理咱都懂。。。但调整起来真的不是那么容易的。。。）
  - 一是要调整自己的动机：比如说我们找实习，最主要的还是能够有一个锻炼自己，让自己成长进步的机会，攒一份实践经历，在秋招中更具有竞争力
  - 二是要保持一个平常心：知足常乐，能拿一个还可以offer就已经很不错了，接下来再接再厉
  - 虽然我嘴上这么说，但是心里真正能这样做还是很难的，希望也能听到大佬们的解惑吧
- 状态很重要
  - 面试摆在面前，我们经常是为了面试而复习，有时候会比较浮躁。对于简单的知识过了一遍又一遍，觉得看了也没太大的作用了，实在是有点不想看了；对于较难的知识感觉之前明明看过的看懂了，这时又忘记了，很难沉下心来再去深入；感觉自己好像这段时间没有成长，没有进步，没有学到什么新东西，以致于状态变得很低迷
  - 我觉得这个情况是很正常的，不要刻意的给自己制造恐慌，不要给自己徒增压力；因为对于一些较为简单的知识，经历过了好几场面试之后，相当于已经起到了巩固作用，并且在回答的叙述上应该也比之前更有逻辑更清晰了，可以不必再花过多时间再反复的看；但一些较难的知识，还是得有针对性的各个击破，经历了好几场面试后，心里应该清楚自己哪些点比较薄弱，哪些点是重点，有针对性的去深入复习，调整好自己的状态，争取下一场能够做到更好

### 3.31 实习一面

面试官很年轻，给人感觉也很好

自我介绍，过程中稍微问了下项目中的个别细节怎么做的
多态讲一下

虚析构函数

进程与线程的区别

进程间通信有哪些

## 线程间通信呢

线程共享用户态虚拟内存空间。

互斥锁、信号量、条件变量、屏障

总而言之，IPC 和 ITC 的区别主要源于进程和线程的内存空间模型不同。  IPC 需要操作系统提供机制来跨进程边界通信，保证隔离性和安全性，但效率相对较低。  ITC 利用线程共享内存的特性，通信更加高效便捷，但需要程序员负责管理共享资源的同步和互斥。  选择哪种通信方式，需要根据具体的应用场景和需求来权衡。



## 自旋锁是什么，怎么实现的

自旋锁是一种低级的互斥锁，它与普通互斥锁最大的区别在于，当线程获取锁失败时，它不会立即阻塞，而是会进入忙等待状态，不断循环检查锁是否释放。  自旋锁的设计目的是为了在临界区非常短的场景下，通过忙等待来避免线程上下文切换的开销，从而提高性能。

自旋锁的实现通常依赖于原子操作，例如 Test-and-Set 或 Compare-and-Swap。  以 Test-and-Set 为例，我们可以用一个原子变量表示锁的状态 (0 表示未占用，1 表示已占用)。  获取锁时，线程会循环执行 Test-and-Set 操作，如果返回值是 1，则继续自旋；如果返回值是 0，则表示成功获取锁。  释放锁时，只需要将锁变量重置为 0 即可。

自旋锁的优点是低延迟，在短临界区且低竞争的场景下性能很高。  缺点是会浪费 CPU 资源进行忙等待，在高竞争或长临界区场景下效率不高，并且可能导致优先级反转问题。  因此，自旋锁更适用于临界区非常短小的场景。

自旋锁常用于操作系统内核、低级系统编程等对性能要求极高的场景，以及临界区非常短小的场合。  但需要谨慎使用，避免在高竞争或长临界区场景下滥用，导致 CPU 资源浪费和性能下降。



## 低地址到高地址说一下进程的虚拟地址空间

在Linux系统中，进程的虚拟地址空间从低地址到高地址依次为：保留区（防止空指针访问）、代码段（存放可执行指令）、已初始化数据段（.data）、未初始化数据段（.bss）、堆（动态内存分配，向高地址增长）、内存映射区域（共享库和文件映射）、栈（函数调用管理，向低地址增长），以及高地址的内核空间。
这种布局通过虚拟内存机制实现了进程间的隔离，同时堆和栈的增长方向相反，以避免内存冲突。现代系统还会通过地址空间随机化（ASLR）提高安全性。



```
高地址 ┌───────────────────┐
      │       Kernel      │ ← 内核空间 (用户不可见)
      ├───────────────────┤
      │   Environment &   │ ← 环境变量、命令行参数
      │    Command Line   │
      ├───────────────────┤
      │       Stack       │ ← 向低地址增长
      ├───────────────────┤
      │ Memory-Mapped     │ ← 共享库、mmap区域
      │      Region       │
      ├───────────────────┤
      │       Heap        │ ← 向高地址增长
      ├───────────────────┤
      │      .bss         │ ← 未初始化数据段
      ├───────────────────┤
      │      .data        │ ← 已初始化数据段
      ├───────────────────┤
      |		 .rodata	  | ← 只读数据段
      ├───────────────────┤
      │      .text        │ ← 代码段
      ├───────────────────┤
低地址 │    Reserved       │ ← 空指针保护区
      └───────────────────┘
```

“`.bss` 存放未初始化或零初始化的全局变量和静态变量，不占用磁盘空间；`.data` 存放已初始化的全局变量和静态变量，占用磁盘空间；`.rodata` 存放只读数据（如字符串常量和 `const` 变量），权限为只读。例如：

- `int a;` → `.bss`
- `int b = 10;` → `.data`
- `const char* s = "Hello";` → 字符串 `"Hello"` 在 `.rodata`。”



## 共享库的映射区是做什么的，讲了下mmap映射到文件对象，设置为有效位无效，访问时再按需调页

共享库映射区是进程虚拟内存中用于加载动态库（如 `.so` 文件）的区域。它的核心作用是让多个进程共享同一份库代码，节省内存。例如，所有使用 `libc.so` 的进程只需在物理内存中保留一份代码副本，通过写时复制（COW）机制保护数据私有性。技术上，动态链接器通过 `mmap()` 将库文件映射到该区域，并利用 PIC（位置无关代码）实现灵活加载。我们可以通过 `/proc/<pid>/maps` 查看具体映射情况。

“防止 `LD_PRELOAD` 攻击需多层级防御：

1. **清除环境变量**：程序启动时调用 `unsetenv("LD_PRELOAD")`。
2. **静态链接**：编译时加 `-static` 避免动态库依赖。
3. **路径隔离**：通过 `RPATH` 指定可信库路径。
4. **权限控制**：`setuid` 程序自动忽略 `LD_PRELOAD`，或使用 `SELinux` 限制。
5. **运行时检测**：检查关键函数是否来自合法库（如 `libc.so`）。
   例如，`sudo` 通过 `secure-execution` 模式防御此类攻击。”



TCP了解多少

## 那什么时候会收到RST报文段

1. 向一个不存在的端口发起请求：端口未监听
2. 服务端应用程序异常终止
3. 半打开连接
4. 连接超时
5. 防火墙、accept队列已满



那报文段为什么会滞留呢



那说一说四次挥手



## 服务器大量处于TIME_WAIT状态，可能的原因，造成什么影响，怎么解决（解决方案没答上来）



## 那大量处于close_wait呢（答错了，理解成LAST_ACK状态了，但面试官也没说）

当一个连接长时间停留在`CLOSE_WAIT`状态时，问题通常出在被动关闭方。具体来说，是运行在这个主机上的应用程序在收到对方的FIN并回复ACK后，没有及时调用`close()`来关闭这个套接字。

**大量CLOSE_WAIT状态的危害：**

- **资源泄露：** 每个处于`CLOSE_WAIT`状态的连接仍然占用着系统资源，如文件描述符、内存等。如果数量过多，可能会耗尽这些资源，导致新的连接无法建立，或者影响系统的整体性能。
- **端口耗尽：** 虽然`CLOSE_WAIT`本身不直接导致端口耗尽（`TIME_WAIT`更容易导致），但大量的未关闭连接会使应用程序无法释放相关端口，间接影响可用端口。
- **应用程序性能下降：** 如果应用程序的线程或进程因为等待这些未关闭的连接而阻塞，会导致应用程序响应变慢甚至无响应。

**如何解决大量CLOSE_WAIT状态的问题：**

解决`CLOSE_WAIT`问题的核心在于**确保应用程序在检测到对端关闭连接后，能够及时、正确地关闭自己的套接字**。



做算法题：反转链表



做算法题：二叉搜索树找到第k小的节点

问了下，是否平常这些题都做过，说像这种二叉树遍历层次、深度遍历基本的都会
接着准备让做难度大点的：大概就是有向图中判断是否出现环了，只给出依赖关系，问了下是否给出总的节点个数，说没给，正在纸上写画准备思路，面试官说这题先放下，没什么时间了，再问下别的
数据库会不会
存储or队列了解吗（说了一下一致性哈希），那如果服务器节点很少也这样做吗（说可以用虚拟节点）
有什么要问我的

总结：有个别题目深入下去没答上来，但总体还好，放松心态，语速较慢逻辑清晰的说。

### 4.2 实习二面

面试官人也很好，遇到不会的，老实说不会，他说没关系；但似乎他网络不太好，开始调了差不多十分钟

主要用什么语言，还有用其他语言吗

IO模型有哪些



用的最多的应该算IO多路复用模型，讲讲它的优缺点



知道正则吗



linux命令了解吗



## 怎么查看端口号占用情况

`netstat -ltn` 或 `ss -ltn` 

lsof -nP -i :端口号



## 有一个日志文件，里面每一行都有ip、time、context等信息，怎么查询某个ip有多少个

`grep -c "192.168.1.100" your_log_file.log`

`grep "192.168.1.100" your_log_file.log | wc -l`



C++11里面auto有什么用，不给初始值可以吗



## volatile有什么用

**volatile 的作用就是告诉编译器：**

- **每次访问 (读或写) volatile 变量时，都必须真正地去访问内存位置。** 不得进行寄存器缓存。
- **对 volatile 变量的访问顺序相对于是严格的。** 编译器不会随意重排序 `volatile` 变量的读写操作（尽管它不能保证这些操作不与非 `volatile` 变量的操作重排序，这需要内存屏障或原子操作）。

**需要注意：**

- `volatile` 只解决了编译器优化引入的问题，它**不是**一个同步机制。
- `volatile` **不能保证操作的原子性**。例如，`volatile int counter; counter++;` 在多线程环境下仍然不是线程安全的，`counter++` 操作可能被中断，导致竞争条件。对于需要原子操作的场景，应该使用 `<atomic>` 头文件中的原子类型。
- `volatile` **不能提供内存排序保证**（Memory Ordering）。在复杂的并发场景下，仅仅使用 `volatile` 不足以确保不同线程看到一致的内存状态，可能还需要内存屏障 (Memory Barriers) 或 C++11 引入的 `<atomic>` 提供的内存顺序控制。



const和#define的区别



进程虚拟地址空间分布



堆和栈的区别



设计模式了解吗



那写一个单例模式吧，写一个好点的（写了饿汉模式）



那这种模式有什么不好之处呢



那再写一个懒汉模式（问了是否需要考虑线程安全，说尽可能写好的，还问了下，加锁解锁部分可以用伪代码）



给定a=1，b=2，不给定其他变量，怎么交换它们俩的值



算法题：给定一个数组，有若干个数，找到a+b+c=99，找到所有abc的组合



### 4.3 实习三面

面试官应该是主管或者级别更高的领导，但是也很和蔼，没有表现的很气势压人一等

主要用什么语言，还有用其他语言吗

STL中的map怎么实现的

那map的插入效率是多少呢

基于比较的查找，最好的性能上logn，还有什么查找能突破这个限制

排序算法里面最好的性能上nlogn，能突破这个限制吗

## inline内联函数是否可以递归

是的，C++ 中**可以**将递归函数声明为 `inline`。

但是，这**不意味着**编译器能够或将会把整个递归调用链全部内联。

原因如下：

1. **inline 只是一个建议 (Hint):** `inline` 关键字是给编译器的一个建议，建议编译器在调用点直接插入函数的代码，而不是生成一个函数调用的指令。编译器可以选择忽略这个建议。
2. **递归的本质是函数调用自身:** 如果编译器尝试完全内联一个递归函数，它会在函数体中遇到对自身的调用，然后又尝试内联这个调用，这将导致无限的代码展开，理论上会生成一个无限大的代码。这是不可能的。

**编译器如何处理 inline 递归函数？**

当编译器遇到一个声明为 `inline` 的递归函数时：

- 它**可能**会选择内联递归的**前几次调用**（例如，只内联到递归深度 1 或 2）。
- 在达到编译器设定的内联深度限制后，或者在递归调用自身的地方，编译器会**停止内联**，转而生成一个**普通的函数调用**指令回到函数本身。



## 构造函数中是否能抛出异常

**在构造函数中抛出异常时会发生什么？**

1. 对象的构造被认为**失败**。
2. 该**对象本身的析构函数不会被调用**，因为对象从未被完全构建。
3. 然而，在异常抛出之前**已经成功构造的任何子对象**（包括基类子对象和成员变量子对象）的析构函数**会被调用**。这是 C++ 的堆栈展开 (stack unwinding) 机制的一部分，旨在清理已成功创建的部分资源。
4. 如果在构造函数中使用裸指针 (`new`) 分配了资源，并且在将这些资源放入 RAII（资源获取即初始化）对象（如智能指针）之前抛出了异常，那么这些资源**将会发生内存泄漏**。因此，在构造函数中使用 RAII 技术来管理资源至关重要。

**为什么要在构造函数中抛出异常？**

- **初始化失败：** 例如，构造函数需要打开一个文件、建立网络连接或分配大量内存，但这些操作失败了。此时，对象无法达到一个有效的初始状态。
- **无效的构造参数：** 如果传递给构造函数的参数无效，无法用来创建有效的对象实例。



## linux中CPU调度怎么做的

**总结来说，Linux 的 CPU 调度：**

- 是**抢占式**的。
- 对于大多数普通任务使用 **Completely Fair Scheduler (CFS)**，该调度器基于**虚拟运行时 (vruntime)** 和**红黑树**来实现公平的 CPU 时间分配，并根据**nice 值**调整进程的实际 CPU 份额。
- 对于需要严格时间保证的任务，提供了 **实时调度器 (SCHED_FIFO, SCHED_RR)**，它们的优先级高于普通任务。
- 在多核系统中，通过**负载均衡**机制将任务分布到不同的 CPU 核心上。



这个进程队列是什么队列



操作系统内存分配与释放



算法题：根据前序遍历序列和中序遍历序列求出后续遍历序列



后续问了下其他问题，什么时候可以来实习

有其他师兄在头条吗

毕业之后有什么打算

最近有什么打算（学习、实践两个方面）

还面了哪些公司，offer情况

有什么要问我的

总结：总的来说，一面二面的问题基本上都答上来了，有一点点小瑕疵；三面的话，有个别不知道的，但根据自己的情况调节了问题的导向及做出相关回答，面试题有点小可惜，只是两条语句顺序调整一下就正确了，但没给时间继续调了；有时候面试官问问题，需要适当的去询问一下问题的详情，但有时候也要注意，不要问的太细了，问得太细又容易把自己的思路、表达等限制住

### 4.30 实习四面（加面）

换了另外一个部门，leader说要加面，只问了几个技术问题

- 自我介绍
- C++内存分配有哪些
- 算法题，数组中的数字都属0～n-1，无序，看是否有重复
- 如果是0～n呢
- 什么时候毕业，毕业后的打算
- 平时怎么学习
- 工作地点
- 实习时间
- 有什么要问的