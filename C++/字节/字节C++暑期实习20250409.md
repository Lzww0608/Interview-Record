# 字节C++暑期实习20250409

### 一面

介绍科研经历，介绍了一通啥也没问，直接做题。（因为科研方向真的很偏啊）

## 找数组中的前k大个数，有哪些方法，分析时间复杂度和空间复杂度，实现其中一种，最后写了一个用小顶堆实现的

1. 直接排序，快排 
2. 堆，大小为k， O(nlog(k))
3. 快速选择 O(n)
4. 计数排序

总结：

范围小：计数排序

k小：堆排序

k接近n：快速选择



## 海量IP，给定IP，输出IP出现的次数，分析时间复杂度和空间复杂度，答了字典树，哈希，位图

哈希表、分片哈希针对单机内存不足、布隆过滤器针对高并发查询

前缀树



## select poll epoll区别，什么时候用select和poll

1. 跨平台兼容性，`epoll`是Linux，而`select` `poll`是POSIX
2. 文件描述符数量少
3. 旧系统兼容性



sizeof



C++内存模型，常量存储区，静态变量和全局变量

![1714398082171](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\1714398082171.png)

虚函数的实现

udp适用于什么场景

tcp和udp可以绑定到同一个端口吗？如何实现



## http协议，connection选项的作用

1. 控制TCP连接的持久性：
   - 在HTTP/1.0中，通过 `Connection: keep-alive` 启用持久连接，减少重复握手开销；
   - 在HTTP/1.1中，默认启用持久连接，但可通过 `Connection: close` 显式关闭。
2. 管理逐跳头字段：
   - 标记如 `Upgrade`、`Keep-Alive` 等字段，确保它们仅由当前代理或服务器处理，不被转发。

例如，当客户端需要升级到WebSocket协议时，需发送：

```http
Connection: Upgrade  Upgrade: websocket
```

此时，`Connection: Upgrade` 告知中间节点 `Upgrade` 字段需在当前连接处理，而非传递到目标服务器。”



如何优化一条sql的查询语句

msyql有哪些索引

联合索引，最左匹配的原理

redis有哪些淘汰策略



### 二面

研究生做了哪些工作
科研发论文的过程

## 概率题：一个地方的夫妻，一胎生了男孩继续生，生了女孩不再生，二三四五胎…亦然，直到生个女孩，问最后男孩女孩的比例，问一个夫妻生男孩的个数的期望是多少

从概率的角度分析，虽然生育策略是生到女孩为止，但这仅仅是一个停止生育的条件。每次怀孕生男生女的概率是独立的，都是 50%。因此，从宏观和长期来看，大量夫妻生育后，男孩和女孩的整体比例依然会接近 1:1。



## 概率题：有一个函数rand7可以随机生成0到7，问如何使用rand7实现rand5，证明机会均等。又问如何使用rand5实现rand7。

1. **调用 rand7() 生成一个数 num。**
2. 判断 `num` 是否在 0 到 4 的范围内 (包含 0 和 4)。
   - 如果 `num` ≤ 4，则 **接受** 这个数，并将其作为 `rand5()` 的结果返回。
   - 如果 `num` > 4 (即 `num` 为 5 或 6)，则 **拒绝** 这个数，并 **重复步骤 1**，重新生成随机数。

先乘以5，再与另一个Rand5结果相加。例如，Rand5 * 5可以生成0、5、10、15、20，然后加上另一个Rand5，可以得到0-24的随机数。这种方法的缺点是，由于它实际上是生成了一个更大的范围（Rand25），并且只是在其中取子集（0-6），因此效率较低。为了提高效率，我们考虑对7进行求余。但问题是我们从0-24的数中取余，得到的分布并不均匀。为了解决这个问题，我们可以先用Rand25生成一个0-21的数（这是Rand21），然后对7取余。这样，我们得到了一个0-6的数。





## socket编程的流程，accept调用和三次握手的关系，accept什么时候会阻塞，accept队列是由谁维护的

1. **创建 Socket (socket):**
   - 使用 `socket()` 函数创建一个 socket 文件描述符。
   - 需要指定地址族 (Address Family，例如 `AF_INET` for IPv4) 和 socket 类型 (Type，例如 `SOCK_STREAM` for TCP)。
   - 这一步相当于在操作系统内核中申请一个 socket 资源，用于后续的网络通信。
2. **绑定地址和端口 (bind):**
   - 使用 `bind()` 函数将 socket 文件描述符与本地的 IP 地址和端口号绑定。
   - 对于服务端，需要绑定一个固定的端口号，以便客户端能够连接到该端口。
   - 如果绑定地址设置为 `INADDR_ANY` (或者 IPv6 的 `in6addr_any`)，则表示绑定到本机的所有网卡地址。
3. **监听连接 (listen):**
   - 使用 `listen()` 函数将 socket 文件描述符设置为监听状态，开始监听来自客户端的连接请求。
   - `listen()` 函数需要一个 `backlog` 参数，用于指定等待连接队列的最大长度。这个队列用于存放已完成三次握手但尚未被 `accept` 接受的连接。
4. **接受连接 (accept):**
   - 使用 `accept()` 函数从监听 socket 的等待连接队列中取出一个已完成三次握手的客户端连接。
   - `accept()` 函数会返回一个新的 socket 文件描述符，这个新的描述符用于与 **特定的客户端** 进行数据传输。
   - 原始的监听 socket 文件描述符仍然保持监听状态，用于接受来自其他客户端的连接请求。
5. **数据传输 (read/write, send/recv):**
   - 使用 `read()`/`write()` 或 `send()`/`recv()` 等函数，通过 `accept()` 返回的新 socket 文件描述符与客户端进行双向的数据通信。
   - 服务端可以接收客户端发送的数据，并向客户端发送响应数据。
6. **关闭连接 (close):**
   - 当数据传输完成后，或者连接不再需要时，使用 `close()` 函数关闭 `accept()` 返回的新 socket 文件描述符以及监听 socket 文件描述符，释放 socket 资源。
7. **总结流程:**  `socket()` -> `bind()` -> `listen()` -> `accept()` -> `read`/`write` (或 `send`/`recv`) -> `close()`



**简而言之，三次握手是 TCP 连接建立的过程，由内核 TCP 协议栈完成；accept() 是服务端应用程序接受已完成三次握手的连接，并获取用于数据通信的新 socket 的过程。**  可以理解为，三次握手是 "建房子"，`accept()` 是 "开门迎接客人"。



`accept()` 默认情况下是一个 **阻塞调用**。这意味着：

1. **无连接请求时阻塞：**  如果监听 socket 的 **已完成三次握手连接队列为空**，`accept()` 调用会 **阻塞 (block) 线程或进程**，即程序会暂停执行，等待新的客户端完成三次握手并加入到队列中。
2. **队列非空时返回：**  一旦有新的客户端完成三次握手，操作系统内核会将这个已完成的连接放入到监听 socket 的等待连接队列中。  此时，阻塞在 `accept()` 的线程或进程会被 **唤醒**，`accept()` 函数会从队列中取出一个连接并返回一个新的 socket 文件描述符，程序继续向下执行。
3. **非阻塞 Socket 和 select/poll/epoll：**  可以将监听 socket 设置为 **非阻塞模式**。  在非阻塞模式下，如果等待连接队列为空，`accept()` 调用会 **立即返回错误 (例如 EAGAIN 或 EWOULDBLOCK)**，而不是阻塞。  服务端程序可以结合 `select`、`poll`、`epoll` 等 I/O 多路复用机制来轮询监听 socket 的可读事件，当监听 socket 可读时 (表示有新的连接请求)，再调用 `accept()`，这样可以避免 `accept()` 阻塞主线程，提高并发处理能力。



**总结：accept 队列 (等待连接队列) 是由操作系统内核 TCP 协议栈维护的，用于存放已完成三次握手但尚未被应用程序 accept() 的连接。队列的最大长度受 listen() 函数的 backlog 参数限制。**



编程：之字形打印二叉树

### 三面

研究生做了哪些工作
项目，这里面的细节问了很多，感觉每次都能问到痛点
协程介绍一下，协程怎么调度
python java了解多少



## 一个服务如何提高并发

要提高服务的并发能力，首先需要明确当前的瓶颈在哪里。 常见的瓶颈可能包括 CPU 密集型、I/O 密集型、内存瓶颈、锁竞争、网络带宽、数据库瓶颈以及外部服务依赖等等。  我们需要通过监控和性能分析工具，例如 CPU profiler, 内存 profiler, I/O 监控等，来定位具体的瓶颈。

针对不同的瓶颈，我们可以采取不同的应用层优化策略。 对于 I/O 密集型服务，异步编程是关键。 对于 CPU 密集型服务，可以考虑多线程或多进程。  连接池和缓存可以减少 I/O 开销。  优化算法和代码可以提升效率。  将服务设计成无状态的，有利于水平扩展。  同时，限流和熔断机制可以保护服务在高并发下的稳定性。

除了应用层优化，系统层面的优化也很重要。  我们可以进行操作系统内核调优，调整资源限制，优化网络协议，例如使用 HTTP/2。  负载均衡是实现水平扩展，提高并发能力的关键系统层技术。

在架构层面，我们可以考虑微服务架构，将系统拆分成更小的服务单元。  引入消息队列可以实现异步处理和流量削峰。  构建分布式系统是应对大规模并发的根本方法。  对于静态资源，CDN 可以有效分担压力。

数据库往往是并发的瓶颈，数据库优化至关重要。  包括索引优化、查询优化、读写分离、分库分表、数据库缓存以及考虑使用 NoSQL 数据库等。

最后，提高并发是一个持续优化的过程。  我们需要建立完善的监控体系，监控各项关键指标，并进行持续的性能测试和调优，根据监控数据和测试结果，不断改进我们的优化策略。



## 场景题：一千台服务器两两连接，服务器之间的延迟不断变化，如何确定任意两台服务器之间的最短路径，答了floyd算法，问floyd算法怎么写。最后写两个函数，一个函数根据服务器之间的延迟更新图，一个函数实现迪杰斯特拉算法。

考虑到我们需要计算任意两台服务器之间的最短路径，并且网络规模适中，我倾向于选择 **Floyd-Warshall 算法**。  Floyd-Warshall 算法专门用于解决 all-pairs shortest paths 问题，实现简单，且在稠密图上效率不错。  虽然 Dijkstra 算法也可以，但需要运行多次，效率相对较低。  Bellman-Ford 算法则更不适合这个场景。



实习时长

### 感受

一二三面连着，一气呵成，因为没想到还会问概率题，中间二面让给问懵了，两个概率题答得都很差，当时以为二面都要挂了，还好面试官给了三面的机会。隔天进行了HR面，问得都是些常规问题，告知下周五之前出结果。