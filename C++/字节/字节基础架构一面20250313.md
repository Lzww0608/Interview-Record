# 字节基础架构一面20250313



字节后端开发-基础架构一面（也不知道过没过）

开头自我介绍，开始吟诵，面试官对我的qt+硬件+服务器项目不感兴趣便开始询问使用语言是否为cpp。

## 1.使用过哪些cpp11以上新特性。

答:智能指针三剑客（shared_ptr, unique_ptr, weak_ptr）.....

1. 智能指针
2. lambda表达式
3. std::unordered_map
4. auto, nullptr, final, constexpr
5. && universal reference



## 2.开始询问shared_ptr的底层实现。
答:引用计数器+裸指针。

控制块：引用计数、弱引用计数、裸指针、删除器、分配器 （原子操作）



## 3.shared_ptr 解决了普通指针的什么问题。
答:RAII对象创建和析构时能自动管理资源，解决内存泄露。





## 4.是否能设计一个shared_ptr，这个shared_ptr里面有哪些成员变量。只答出来:裸指针+引用计数器，也许对数组需要记录长度，析构时范围释放。

面试官不语。





## 5.weak_ptr是否使用过，具体api调用。答:创建对象时需要指向shared_ptr, 拿指针时需要lock。
是否能设计一个weak_ptr。（ 给菜鸡干懵了，便开始临时发挥。）
答:也需要一个引用计数器来记录shared_ptr的引用计数器，当lock时，若shared_ptr引用计数器为0时，他返回空指针。



## 6.unique_ptr的使用场景，我就往单例上靠。

1. 工厂模式创建对象
2. 动态分配对象的自动清理  {}
3. 独占所有权： 线程
4. 只支持移动语义的时候



## 7.进程间通信哪些方式。开始吟唱。

提到了共享内存和消息队列，消息队列怎么实现 ，开始说是一个单向队列（不知道linux系统底层是但还是双），就答一个消费者模型的单向queue。还问了本地套接字的使用api调用过程。

Linux中单向队列，双队列实现双向。<mqueue.h>



## 8.线程同步方式。开始吟唱。
提到了互斥锁，互斥锁底层实现 。哥们不行了，提到了线程阻塞和休眠。问，怎么实现线程阻塞和休眠，答涉及线程调度，深了不会了。

1. 互斥锁 + 条件变量
2. 信号量 PV操作
3. 原子操作、读写锁、自旋锁



## 9.一道设计题，主线程创建一个资源在子线程消费完之前wait住，简单的用mutex对一个int val加锁和std::thread实现了对这个共享变量的访问。面试官看完能运行就放我走了。





看到的面试官都好累（上班不容易呀），明天又要干那b横项，希望能早日毕业，早日放我实习， 。