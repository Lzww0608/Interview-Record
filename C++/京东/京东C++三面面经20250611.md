## 京东C++三面面经20250611

8/10

#### 一面

自我介绍，项目介绍
c++11新特性
右值引用
智能指针（shared_ptr, weak_ptr）
敲代码（先序遍历数组+中序遍历 还原二叉树）

8/17

#### 二面

自我介绍，项目介绍

## move语义（move避免了内存的额外消耗，指针也可以，为什么不用指针）

**因为指针只解决了“避免拷贝”这一个表层问题，却引入了“所有权混乱”、“异常安全隐患”和“代码意图模糊”等一系列更深层次、更危险的问题。**

C++11的移动语义，特别是与智能指针结合使用时，提供了一个**全面**的解决方案。它不仅在性能上达到了和指针同样的目标（避免拷贝），更重要的是，它通过**显式的所有权管理**和**RAII**，从根本上解决了资源管理的正确性和安全性问题，这正是现代C++语言设计的精髓所在。



shared_ptr与weak_ptr的应用场景，性能区别
shared_ptr怎么实现计数器（源码）

## 基于阻塞的服务器，buffer是1000个字节，当客户端发送了100个字节，服务端可能收到多少个字节。

`bytes_received` 的值**不一定**是100。它的可能取值有很多种，这背后的根本原因是：**TCP是一种面向字节流的协议**。

这意味着，TCP协议本身不保留“消息”的边界。从TCP的视角看，它只知道一端向另一端发送了一连串的字节数据，像一条河流一样。它不关心发送方调用了多少次`send`，或者每次`send`了多少字节。`recv` 函数的任务只是从操作系统内核的接收缓冲区（Receive Buffer）中，把数据“捞”到我们应用层的`buffer`里。

+ 1-100

+ 大于100： 粘包、nagle

+ 0： 关闭链接

+ -1：

  + 后续操作：

     此时，我们必须检查全局变量`errno`（在Linux/Unix上）或调用来获取具体的错误码。 

    - 对于阻塞socket，常见的错误可能是 `ECONNRESET`（连接被对方重置）、`ETIMEDOUT`（连接超时）等。
    - 如果是非阻塞socket，还可能返回 `EAGAIN` 或 `EWOULDBLOCK`，但这表示“现在无数据可读”，不算是真正的错误。



8/26

#### HR面

自我介绍
项目不是c++开发的，关于算法落地的项目，现在为什么要找c++开发