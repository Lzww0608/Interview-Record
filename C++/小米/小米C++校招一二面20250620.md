# 小米C++校招一二面20250620

8.28投递

9.1 19点笔试

#### 9.7 15点 一面

45min
自我介绍
项目介绍
深挖项目
C++的内存管理，内存里面栈和堆的区别
static修饰变量和函数有什么用
C++的struct和class的区别是什么
多线程和多进程的理解，
线程同步，自旋锁和互斥锁，信号量

## 什么是死锁，如何避免死锁

“针对这四个条件，业界通常有三种处理死锁的策略：**死锁预防（Prevention）**、**死锁避免（Avoidance）** 和 **死锁检测与恢复（Detection & Recovery）**。

- **死锁预防**：这是一种静态策略，通过在设计和编码阶段制定一些规则，从根本上破坏死锁发生的某一个必要条件，使其永远不会发生。
- **死锁避免**：这是一种动态策略，在资源分配的过程中，通过某种算法（如银行家算法）来判断本次分配是否会使系统进入不安全状态，如果会，则不予分配，让线程等待。
- **死锁检测与恢复**：这种策略允许死锁发生，但系统会有一个专门的机制来定时检测是否发生了死锁。如果检测到死锁，则会采取一些恢复措施，比如剥夺资源或终止进程。

在我的实际工作中，绝大部分场景下，我们更关注和采用**死锁预防**的策略，因为它对应用层开发者来说最直接、最可控。死锁避免算法（如银行家算法）因为需要预知未来对资源的最大需求，且开销较大，在通用的后端服务中较少直接应用。而死锁检测与恢复通常是数据库或操作系统层面需要考虑的，应用层面上较少自行实现。”

“在 C++ 后端开发中，要预防死锁，我主要会从以下几个方面入手，核心思想是破坏‘请求与保持’和‘循环等待’这两个条件：

1. **破坏‘请求与保持’条件：一次性获取所有资源** 这个策略要求线程在执行前，一次性申请它需要的所有锁。如果无法一次性获得全部锁，则它必须释放所有已经持有的锁，然后重新尝试。 在 C++17 中，我们可以非常方便地使用 `std::scoped_lock` 来实现这一点。`std::scoped_lock` 是一个 variadic template（可变参数模板），可以同时接收多个互斥量，它会保证以一种不会产生死锁的算法（内部通常是死锁避免算法）来同时锁定这些互斥量。

   ```c++
   // 假设有两个互斥量 mtx1, mtx2
   // 使用 std::scoped_lock 可以安全地同时锁定它们
   void my_function() {
       std::scoped_lock lock(mtx1, mtx2); // 构造时加锁，析构时自动解锁
       // ... 安全地访问被 mtx1 和 mtx2 保护的资源 ...
   }
   ```

   在 C++11/14 中，虽然没有 `std::scoped_lock`，但我们可以用 `std::lock` 和 `std::lock_guard` 组合来达到类似的效果：

   ```c++
   void my_function_cpp11() {
       std::lock(mtx1, mtx2); // 死锁避免算法，保证两个锁都被锁上
       std::lock_guard<std::mutex> lock1(mtx1, std::adopt_lock);
       std::lock_guard<std::mutex> lock2(mtx2, std::adopt_lock);
       // ...
   }
   ```

2. **破坏‘循环等待’条件：按序加锁（锁序，Lock Hierarchy/Lock Ordering）** 这是最常用也最重要的一种死锁预防手段。我们的团队会约定一个全局的、唯一的顺序来获取锁。例如，为系统中所有的互斥量分配一个唯一的 ID，然后规定，任何线程如果需要获取多个锁，都必须按照 ID 从小到大的顺序来获取。 比如，线程 A 和线程 B 都需要锁 `m1` 和 `m2`。我们规定必须先锁 `m1` 再锁 `m2`。这样，即使 A 持有 `m1` 想获取 `m2`，而 B 想获取 `m1`，B 会因为无法先获取到 `m1` 而阻塞，绝对不会出现 A 持有 `m1` 等待 `m2`，同时 B 持有 `m2` 等待 `m1` 的情况，从而破坏了循环等待。 这个规则需要通过代码审查（Code Review）和静态分析工具来强制保证。

3. **其他辅助策略（破坏‘不可剥夺’或减少锁的使用）**

   - 使用 `std::timed_mutex`：当尝试获取锁时，设置一个超时时间。如果超时仍未获取到锁，就先释放自己已经持有的锁，等待一小段时间再重试。这相当于一种“主动放弃”，间接破坏了“请求与保持”或“不可剥夺”条件。 

     ```c++
     void transfer(Account& from, Account& to, double amount) {
         std::unique_lock<std::timed_mutex> lock_from(from.mtx, std::defer_lock);
         std::unique_lock<std::timed_mutex> lock_to(to.mtx, std::defer_lock);
     
         // C++17 的 std::lock 也可以，这里用循环演示思想
         while (true) {
             if (lock_from.try_lock()) {
                 if (lock_to.try_lock_for(std::chrono::milliseconds(10))) {
                     // 成功获取两个锁
                     from.balance -= amount;
                     to.balance += amount;
                     break;
                 } else {
                     // 获取 to 失败，释放 from 的锁，避免死锁
                     lock_from.unlock();
                     std::this_thread::yield(); // 让出CPU，稍后重试
                 }
             }
         }
     }
     ```

   - **减少锁的粒度和范围**：只在绝对必要的地方加锁，并且尽快释放。锁持有的时间越短，发生冲突和死锁的概率就越低。

   - **使用无锁数据结构**：对于一些简单的场景，比如计数器，可以使用 C++ 的 `std::atomic` 原子操作，它能保证线程安全，且完全不需要加锁，自然也就没有死锁问题。对于更复杂的场景，如无锁队列，可以避免使用锁，但其实现复杂度和维护成本会显著提高。



没有手撕代码
反问：部门主要是做什么的？面试官说主要是用C语言开发，Linux驱动方面的
面试体验还可以，但是有莫名感觉会凉

#### 9.17 二面

45min
C++虚函数
问操作系统
进程与线程
为什么有了进程还需要线程
知道协程吗
进程间的通信方式，每个方式比较一下
线程间的通信方式，为什么线程间通信不需要进程间那样通过管道之类的方法？
线程间的同步方式
如果加了互斥锁，那么另一个线程访问到加了互斥锁的资源，会怎么样？还有没有CPU？为什么？（掌握不牢，磕磕巴巴）
死锁是什么？死锁的条件？
什么是虚拟内存？为什么需要虚拟内存？有了虚拟内存就一定可以实现内存隔离吗？一个进程就一定不能通过指针误操作导致影响其他进程的数据吗？虚拟内存的页面置换是通过什么实现的？（被问麻了）
socket编程相关：select，poll和epoll
此外还针对我的回答问了好多为什么？不停地深挖，难顶
最后面试官表示我是学通信的，掌握成这样已经可以了😅
小米的C++面试特别注重操作系统的概念理解

9.23收到HR电话，告知了薪资情况，说是要月底给答复。