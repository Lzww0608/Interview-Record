## 浩鲸科技20240930

## 怎么考虑一个软件的性能

### 1. **性能评估指标**

了解衡量软件性能的常见指标，是进行性能考量的首要步骤。这些指标可以用来评估不同类型的应用程序，包括前端、后端、移动应用程序等。

- **响应时间（Response Time）**：用户发起请求到接收到响应的时间。这通常用于衡量Web应用和API的性能。
- **吞吐量（Throughput）**：单位时间内处理的请求数。它表示系统的处理能力。
- **延迟（Latency）**：从发送请求到开始收到第一个字节数据的时间。延迟较小代表网络传输或处理的速度较快。
- **资源使用（Resource Utilization）**：CPU、内存、磁盘I/O和网络带宽的使用情况。
- **并发用户数（Concurrency）**：同时访问系统的用户数量。可以测试系统在高并发场景下的表现。
- **错误率（Error Rate）**：单位时间内发生的错误或失败的请求数。
- **可扩展性（Scalability）**：当系统负载增加时，系统能否保持良好的性能。

### 2. **性能瓶颈分析**

在实际开发和测试中，性能瓶颈往往是影响软件性能的主要因素。找到并优化这些瓶颈是提升性能的关键。

- **数据库性能瓶颈**：例如，数据库查询过慢、索引不合理、频繁锁表等。
- **I/O 瓶颈**：磁盘和网络I/O 读写过慢。
- **CPU 瓶颈**：CPU 使用率过高或多线程竞争导致上下文切换频繁。
- **内存瓶颈**：内存泄漏、GC（垃圾回收）引起的停顿。
- **网络瓶颈**：带宽限制或网络延迟。

### 3. **性能测试策略**

性能测试是评估系统性能表现的有效手段。常用的性能测试策略包括：

- **负载测试（Load Testing）**：测试系统在正常和高负载情况下的性能表现。
- **压力测试（Stress Testing）**：测试系统在超过最大设计负载情况下的反应，评估系统的稳定性。
- **稳定性测试（Stability Testing）**：测试系统长时间运行时的稳定性，观察是否有内存泄漏或资源枯竭。
- **容量测试（Capacity Testing）**：确定系统能够支持的最大用户数或事务量。
- **基准测试（Benchmarking）**：通过标准化的测试用例来测量不同系统组件的性能表现。



## 分布式的进程间的通信

### 1. **远程过程调用（RPC）**

RPC 是分布式系统中最常用的通信方式之一。它允许程序像调用本地函数一样，调用远程服务器上的服务。常用的 RPC 框架有 gRPC、Thrift、Dubbo 等。

- **gRPC**：由 Google 开发，基于 HTTP/2 协议，使用 Protocol Buffers（protobuf）进行序列化和反序列化，支持多种语言。
- **Apache Thrift**：由 Facebook 开发，支持多种语言间的通信，并且具有高效的序列化机制。
- **Dubbo**：阿里巴巴开源的 RPC 框架，主要用于 Java 服务间的通信。

### 2. **消息队列（Message Queue）**

消息队列是一种异步通信机制，通常用于解耦服务、削峰填谷、分布式事务等场景。常用的消息队列包括 Kafka、RabbitMQ、ActiveMQ、RocketMQ 等。

- **Kafka**：由 LinkedIn 开发，适用于高吞吐量的日志和事件流处理。
- **RabbitMQ**：基于 AMQP 协议，支持复杂的路由规则和消息确认机制。
- **RocketMQ**：阿里巴巴开源的分布式消息队列，适用于金融级别的高可用、高可靠场景。

### 3. **共享存储（Shared Storage）**

通过共享存储来进行进程间通信也是一种常见的方式。在分布式系统中，共享存储通常用于进程间的状态同步、分布式锁、集群协调等场景。

- **分布式文件系统（如 HDFS、Ceph）**：多进程可以通过共享文件进行通信和数据交换。
- **Redis/Memcached**：通过共享内存（key-value 存储）进行进程间的数据交换。
- **Etcd/ZooKeeper**：通常用于分布式系统中的配置管理、服务注册和分布式锁。

### 5. **HTTP/RESTful API**

HTTP 是一种通用的进程间通信协议，通常用于微服务架构中不同服务之间的通信。使用 RESTful API，可以通过 URL 和 HTTP 方法（GET、POST、PUT、DELETE）来调用远程服务。



## 快排和归并排序的原理

#### 快速排序的原理

1. **选择基准元素（Pivot）**：
   - 选择数组中的一个元素作为“基准”元素。基准的选择方式可以是随机选择、选择数组的第一个或最后一个元素，也可以选择数组的中间元素。
2. **划分（Partition）**：
   - 通过遍历数组，将小于基准的元素移到基准的左边，大于基准的元素移到基准的右边，从而实现数组的划分。划分后，基准元素处于其最终位置上。
3. **递归排序子数组**：
   - 分别对基准元素左侧和右侧的子数组进行递归排序。
4. **合并**：
   - 快速排序不需要额外的合并操作，因为在划分的过程中，数组已经被排序好。



#### 归并排序的原理

1. **分割（Divide）**：
   - 将数组从中间划分为两个子数组，递归地对每个子数组进行归并排序。
2. **合并（Merge）**：
   - 将两个已经排序的子数组合并为一个有序数组。
3. **合并过程**：
   - 从两个子数组的第一个元素开始比较，将较小的元素放入合并后的数组中，并移动指针直到所有元素都合并完成。



## c和c++区别

+ 面向对象
+ 函数重载和运算符重载
+ RAII
+ STL
+ 命名空间
+ 模板
+ 引用与类型检查



## 多态实现

**编译时多态（静态多态）**：通过**函数重载**和**运算符重载**实现。

**运行时多态（动态多态）**：通过**虚函数**和**继承**实现。



## 构造函数能不能是虚函数

不能。指向虚函数表的指针是在构造函数完成之后才实现，而如果构造函数为虚函数，那么就需要虚函数指针来指向虚函数表找到函数的位置。



## 构造函数能不能抛出异常 会导致什么

构造函数可以在以下情况下抛出异常：

- 在构造过程中发现某些条件不满足，导致对象无法正常构造。
- 内存分配或资源获取失败，例如无法分配足够的内存、打开文件失败等。

```c++
class MyClass {
public:
    MyClass(int value) {
        if (value < 0) {
            throw std::invalid_argument("Value must be non-negative");
        }
    }
};
```

+ **构造函数可以抛出异常**，用于处理构造过程中发现的错误。

+ 如果构造函数抛出异常，对象不会成功构造，析构函数也不会被调用。但已经构造好的基类和成员对象的析构函数会被调用，以避免资源泄漏。

+ 构造函数抛出异常可能会导致资源泄漏，因此应该尽可能使用智能指针和RAII技术来管理资源，确保资源在发生异常时得到正确释放。

+ 使用`try-catch`块可以捕获构造函数中抛出的异常，以防止程序崩溃。



## 什么是野指针

在声明指针时，如果没有初始化指针，它会指向一个随机的内存位置，这种指针被称为野指针。

```c++
int *ptr;  // ptr 未初始化，指向未知地址
*ptr = 10; // 可能导致未定义行为
```

在上述代码中，`ptr`并没有指向一个有效的内存地址，而直接对其进行解引用会导致未定义行为，因为它指向的内存地址可能根本不是程序可访问的区域。



## 进程和线程区别

`Linux`内核中都表示为`task_struct`

#### 本质区别：

进程是资源分配的基本单位，线程是CPU调度的基本单位

1. **定义和结构**：
   - **进程**：进程是程序的一个实例，它在其自己的地址空间中运行。每个进程至少包含一个线程（主线程），并拥有自己的虚拟内存、系统资源和独立的执行环境。进程之间互相隔离，一个进程的崩溃通常不会影响到其他进程。
   - **线程**：线程是进程中的执行单元，也被称为轻量级进程。一个进程可以包含多个线程，它们共享父进程的地址空间和资源，如内存和文件句柄等。线程主要用于实现任务的并行执行。
2. **资源共享**：
   - **进程**：进程之间不共享内存或资源，除非通过进程间通信（IPC）机制显式共享，如套接字、信号量、共享内存等。
   - **线程**：同一进程内的线程共享内存和资源，这使得线程间的数据交换和通信更为容易和快速，但也需要注意同步和互斥问题，以避免竞态条件和死锁。
3. **开销和性能**：
   - **进程**：创建和管理进程的开销相对较大，因为每个进程需要独立的地址空间和系统资源。进程切换涉及更多的时间和资源，如保存和加载不同进程的上下文。
   - **线程**：线程的创建和切换开销较小，因为它们共享相同的环境和资源。线程间的切换只需要较少的资源重新配置。
4. **通信方式**：
   - **进程**：进程间通信需要特定的机制，如管道、消息队列、共享内存等，这些机制通常涉及更复杂的设置和管理。
   - **线程**：由于线程共享同一内存空间，它们可以直接通过读写同一内存区域来进行通信，但这要求程序正确地处理同步问题，以防数据不一致。
5. **应用场景**：
   - **进程**：适用于需要独立运行和资源管理的应用，例如在需要隔离的环境中运行不同的服务时。
   - **线程**：适用于需要高效执行并行任务的情况，尤其是在计算密集型应用中，如服务器端程序、复杂算法的实现等。



## 怎么实现消息队列

### 1. 使用现有消息队列中间件如Kafka，RabbitMQ等



### 2.使用Redis来实现，`list`的`lpush` `rpop`



## 3.自定义实现

注意点：

1. 高并发：异步，线程安全需要加锁
2. 持久化：落到磁盘
3. 发布订阅模式



## 线程互斥该怎么做

1. 使用 `std::mutex` 实现互斥
2. 使用 `std::unique_lock` 和 `std::condition_variable`
3. 使用 `std::shared_mutex` 实现读写锁
4. 使用 `std::atomic` 实现轻量级互斥



## cmake搜索一个库用什么

`find_package()`：查找系统中安装的库。

`add_subdirectory()`：使用你项目中包含的库源代码。

`find_library()`：手动查找库文件路径。

`target_include_directories()` 和 `target_link_libraries()`：手动设置头文件和库文件。

`pkg_check_modules()`：使用 `pkg-config` 查找库。



## gdb调试core文件相关内容

1. 启动 `gdb`：

   ```
   gdb my_program core
   ```

2. 在 `gdb` 中，输入：

   ```
   (gdb) bt
   ```

   你会看到调用栈，找到崩溃发生的函数。

3. 切换到崩溃的栈帧：

   ```
   (gdb) frame 0
   ```

4. 查看局部变量的状态：

   ```
   (gdb) info locals
   ```

5. 打印有问题的指针变量，检查是否是空指针：

   ```
   (gdb) print my_pointer
   ```

这样你就可以找到导致段错误的变量，并追踪其赋值过程以找出错误的原因。