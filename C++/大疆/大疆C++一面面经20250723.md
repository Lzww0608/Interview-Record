# 大疆C++一面面经20250723.md

自我介绍

简单介绍下项目（webserver）

C++部分

C++内存布局

堆和栈的区别

## .data和.bss的区别

- **.data段 (Initialized Data Segment)**: 存储**已初始化**的全局变量和静态变量。这些变量有明确的初始值（非零），因此这些初始值本身需要被存储在可执行文件中，导致可执行文件体积增大。可以把它想象成一个“胖子”，因为它随身携带了“干粮”（初始值）。
- **.bss段 (Block Started by Symbol)**: 存储**未初始化**或**初始化为零**的全局变量和静态变量。对于这些变量，程序只需要记录它们的名称和所需空间大小，而不需要存储具体的初始值（因为默认就是0）。这大大减小了可执行文件的体积。可以把它想象成一个“瘦子”，它只带了一张“饭票”（需要多少空间），饭（全零填充）由操作系统在运行时提供。





为什么要将.data和.bbs分开存储

## 为什么需要.bss段

它主要为了解决两个关键问题：**存储空间**和**加载时间**。

程序的启动过程，本质上是操作系统的加载器（Loader）读取可执行文件，并将其内容映射到内存中。
*   **加载`.data`段**：这是一个实打实的**磁盘I/O操作**。加载器需要从文件中读取`.data`段的所有字节，然后原封不动地拷贝到进程的虚拟内存中。
*   **处理`.bss`段**：加载器看到`.bss`段时，它**不需要从文件读取任何东西**。它只需要在进程的虚拟内存中找到一块相应大小的区域，然后调用一个高度优化的内核函数（相当于 `memset`）将其清零。
**哪个更快？**
毫无疑问，后者的速度要快得多。内存操作的速度比磁盘I/O操作要快上几个数量级。尤其是在现代操作系统中，`.bss`段的清零过程还享受**“写时复制”（Copy-on-Write）和“按需填零”（Zero-Fill-on-Demand）**等高级优化。操作系统甚至不会在加载时立刻分配并清零所有`.bss`内存，而是在该内存页第一次被访问时才进行这个操作，从而将启动开销降到最低。
**结论：** 如果没有`.bss`段，那4MB的零也必须从磁盘上一个字节一个字节地读入内存。这将毫无意义地消耗大量I/O带宽，使得程序的启动变得异常缓慢。`.bss`段的设计将一个昂贵的I/O问题，转换成了一个极其廉价的CPU内存操作问题。



红黑树的特点以及优势

计算机网络部分

TCP三次握手和四次挥手
为什么是三次，不是两次或者四次
TCP拥塞控制

## 如何实现可靠UDP





几个开源的可靠UDP实现（只听过http3.0那个）
UDP和TCP的区别
epoll与select以及poll的区别
为什么epoll更加高效

## 如果客户端突然断电了，服务端如何快速知道



设置TCP不缓存，直接发送
Nagle算法

操作系统部分

进程与线程的定义和区别
线程进程的共享资源和独占资源

## 线程池如何选择合适的线程数（分IO密集和计算密集）

1. **核心原则**：根据任务是**CPU密集型**还是**I/O密集型**来决定策略。目标是最大化CPU利用率，最小化上下文切换开销。
2. **理论公式**：
   - **CPU密集型**: 线程数 ≈ CPU核心数
   - **I/O密集型**: 线程数 = CPU核心数 * (1 + 阻塞系数)  **阻塞系数 = 线程等待时间 / 线程计算时间**
3. **实践方法**：理论公式是起点，**性能压测是终点**。通过监控吞吐量、延迟和CPU利用率等关键指标，进行迭代调优，找到最佳的线程数拐点。
4. **语言相关性**：在C++/Java中，我们直接控制线程池大小。在Golang中，我们更多地是利用其强大的调度器，通过设计不同的Goroutine并发模式来适应任务类型，而不是直接管理线程数。



进程通信方式
虚拟内存
CPU三级缓存
逻辑地址转换成物理地址

22号更新

一面过了，已约二面25号